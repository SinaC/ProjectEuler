using System;
using System.Collections.Generic;
using System.Text;
using CarlJohansen;

namespace ProjetEuler {
    class Program {
        //http://www.numericana.com/answer/numbers.htm#moebius
        //http://www.numericana.com/answer/counting.htm#euler193
        //The On-Line Encyclopedia of Integer Sequences™ (OEIS™)   http://oeis.org/
        #region Tools
        ulong[] Factorials10 = { 1/*0*/, 1/*1*/, 2/*2*/, 6/*3*/, 24/*4*/, 120/*5*/, 720/*6*/, 5040/*7*/, 40320/*8*/, 362880/*9*/, 3628800/*10*/ };
        ulong[] Primes10 = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 };
        private ulong ToUInt64(char c) {
            return Convert.ToUInt64(c) - 48;
        }
        private long ToInt64(char c) {
            return Convert.ToInt64(c) - 48;
        }
        private uint ToUInt32(char c) {
            return Convert.ToUInt32(c) - 48;
        }
        private int ToInt32(char c) {
            return Convert.ToInt32(c) - 48;
        }
        //private bool IsPrime(ulong n) {
        //    ulong sqrtN = (ulong)Math.Sqrt(n);
        //    for (ulong i = 2; i <= sqrtN; i++)
        //        if ((n % i) == 0)
        //            return false;
        //    return true;
        //}
        private bool IsPrime(ulong n) {
            if (n <= 1) return false; // 0, 1
            if (n < 4) return true; // 2, 3
            if (0 == (n & 1)) return false; // even
            if (n < 9) return true; // 0, 1, 4, 6, 8 already rejected
            if (0 == (n % 3)) return false; // multiple of 3
            ulong sqrtN = (ulong)Math.Sqrt(n);
            ulong divisor = 5;
            while (divisor <= sqrtN) {
                if (0 == (n % divisor)) return false;
                if (0 == (n % (divisor + 2))) return false;
                divisor += 6;
            }
            return true;
        }
        //private bool[] BuildSieve(ulong limit) {
        //    bool[] numbers = new bool[limit];
        //    for(ulong i = 0; i < limit; i++ ) numbers[i] = false;
        //    ulong sqrtLimit = 1 + (ulong)Math.Sqrt(limit);
        //    for ( ulong i = 2; i <= sqrtLimit; i++ )
        //        if ( !numbers[i] )
        //            for ( ulong j = i+i; j < limit; j+=i)
        //                numbers[j] = true;
        //    numbers[0] = true; // not prime
        //    numbers[1] = true; // not prime
        //    return numbers;
        //}
        private bool[] BuildSieve(ulong limit) {
            bool[] numbers = new bool[limit + 1];
            ulong sqrtLimit = (ulong)Math.Sqrt(limit);
            for (int i = 0; i < numbers.Length; i++)
                numbers[i] = false; // prime by default
            for (ulong i = 4; i <= limit; i += 2) // mark even number
                numbers[i] = true;
            for (ulong i = 3; i <= sqrtLimit; i += 2) {
                if (!numbers[i])
                    for (ulong j = i * i; j <= limit; j += 2 * i)
                        numbers[j] = true;
            }
            numbers[0] = true; // not prime
            numbers[1] = true; // not prime
            return numbers;
        }
        private ulong SumDigits(ulong number) {
            ulong sum = 0;
            while (number >= 1) {
                sum += number % 10;
                number /= 10;
            }
            return sum;
        }
        private ulong SumDigits(string number) {
            ulong sum = 0;
            foreach (char c in number)
                sum += ToUInt64(c);
            return sum;
        }
        private ulong Factorial(ulong number) {
            ulong fact = 1;
            for (ulong i = 2; i <= number; i++)
                fact *= i;
            return fact;
        }
        private ulong PGCD(ulong a, ulong b) {
            ulong r;
            while (0 != (r = a % b)) {
                a = b;
                b = r;
            }
            return b;
            //while (b != 0) {
            //    a %= b;
            //    if (a == 0)
            //        return b;
            //    b %= a;
            //}
            //return a;
        }
        private bool IsPalindromic(ulong number, ulong baseToTest) {
            ulong num = number;
            ulong rev = 0;
            while (num > 0) {
                ulong dig = num % baseToTest;
                rev = rev * baseToTest + dig;
                num = num / baseToTest;
            }
            return number == rev;
        }
        private bool IsPandigital(string s) {
            char limit = Convert.ToChar(s.Length + 48);
            for (char i = '1'; i <= limit; i++)
                if (-1 == s.IndexOf(i))
                    return false;
            return true;
        }
        private bool IsPandigitalCharRange(string s, char lowerLimit, char higherLimit) {
            for (char i = lowerLimit; i <= higherLimit; i++)
                if (-1 == s.IndexOf(i))
                    return false;
            return true;
        }
        //private int SumFactors(int n) {
        //    int sqrtI = (int)Math.Sqrt(n);
        //    int sum = 1;
        //    int limit = sqrtI;
        //    if (sqrtI * sqrtI == n) {
        //        sum += sqrtI;
        //        limit--;
        //    }
        //    for (int j = 2; j <= limit; j++)
        //        if (0 == (n % j))
        //            sum = sum + j + (n / j);
        //    return sum;
        //}
        //private ulong SumOfDivisors(ulong number) {
        //    ulong sum = 1;
        //    ulong p = 2;
        //    while (p * p <= number && number > 1) {
        //        if (0 == (number % p)) {
        //            ulong j = p * p;
        //            number = number / p;
        //            while (0 == (number % p)) {
        //                j *= p;
        //                number /= p;
        //            }
        //            sum *= (j - 1);
        //            sum /= (p - 1);
        //        }
        //        if (2 == p)
        //            p = 3;
        //        else
        //            p = p + 2;
        //    }
        //    if (number > 1)
        //        sum *= (number + 1);
        //    return sum;
        //}
        private ulong SumOfDivisors(ulong n) {
            ulong prod = 1;
            for (ulong k = 2; k * k <= n; ++k) {
                ulong p = 1;
                while (n % k == 0) {
                    p = p * k + 1;
                    n /= k;
                }
                prod *= p;
            }
            if (n > 1)
                prod *= 1 + n;
            return prod;
        }
        private ulong SumOfProperDivisors(ulong number) {
            return SumOfDivisors(number) - number;
        }
        private string SumString(string a, string b) {
            if (a.Length < b.Length) {
                string swap = a;
                a = b;
                b = swap;
            }
            StringBuilder result = new StringBuilder(a.Length + 1);
            int carry = 0;
            int bIndex = b.Length - 1;
            for (int i = a.Length - 1; i >= 0; i--) {
                int digitA = ToInt32(a[i]);
                int digitB = (bIndex < 0) ? 0 : ToInt32(b[bIndex--]);
                int sum = digitA + digitB + carry;
                carry = (sum >= 10) ? 1 : 0;
                int digit = sum % 10;
                result.Insert(0, digit);
            }
            if (0 != carry)
                result.Insert(0, '1');
            return result.ToString();
        }
        private string SubString(string a, string b) {
            if (a.Length > b.Length)
                b = b.PadLeft(a.Length, '0');
            string complement = "";
            foreach (char c in b)
                complement += 9 - ToInt32(c);
            string sum = SumString(a, complement);
            sum = SumString(sum, "1");
            string difference = sum.Substring(1);
            while (difference[0] == '0')
                difference = difference.Substring(1);
            return difference;
        }
        private ulong Triangle(ulong n) {
            return n * (n + 1) / 2;
        }
        private ulong Square(ulong n) {
            return n * n;
        }
        private ulong Pentagonal(ulong n) {
            return n * (3 * n - 1) / 2;
        }
        private ulong Hexagonal(ulong n) {
            return n * (2 * n - 1);
        }
        private ulong Heptagonal(ulong n) {
            return n * (5 * n - 3) / 2;
        }
        private ulong Octogonal(ulong n) {
            return n * (3 * n - 2);
        }
        private double TriangleIndex(ulong number) {
            return (-1 + Math.Sqrt(8 * number + 1)) / 2;
        }
        private double SquareIndex(ulong number) {
            return Math.Sqrt(number);
        }
        private double PentagonalIndex(ulong number) {
            return (1 + Math.Sqrt(24 * number + 1)) / 6;
        }
        private double HexagonalIndex(ulong number) {
            return (1 + Math.Sqrt(8 * number + 1)) / 4;
        }
        private double HeptagonalIndex(ulong number) {
            return (3 + Math.Sqrt(40 * number + 9)) / 10;
        }
        private double OctogonalIndex(ulong number) {
            return (2 + Math.Sqrt(12 * number + 4)) / 6;
        }
        private bool IsTriangle(ulong number) {
            double n = TriangleIndex(number);
            return n == Math.Truncate(n);
        }
        private bool IsSquare(ulong number) {
            double n = SquareIndex(number);
            return n == Math.Truncate(n);
        }
        private bool IsPentagonal(ulong number) {
            double n = PentagonalIndex(number);
            return n == Math.Truncate(n);
        }
        private bool IsHexagonal(ulong number) {
            double n = HexagonalIndex(number);
            return n == Math.Truncate(n);
        }
        private bool IsHeptagonal(ulong number) {
            double n = HeptagonalIndex(number);
            return n == Math.Truncate(n);
        }
        private bool IsOctogonal(ulong number) {
            double n = OctogonalIndex(number);
            return n == Math.Truncate(n);
        }
        private List<ulong> SqrtContinuedFraction(ulong n) {
            // sqrt(n) = [List[0];(List[1],List[2],...)]
            //http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/cfINTRO.html
            ulong sqrtN = (ulong)Math.Sqrt(n);
            List<ulong> result = new List<ulong>();
            ulong a = sqrtN;
            ulong p = 0;
            ulong q = 1;
            result.Add(a);
            while (true) {
                p = a * q - p;
                q = (n - p * p) / q;
                a = (p + sqrtN) / q;
                result.Add(a);
                if (q == 1)
                    break;
            }
            return result;
        }
        private ulong Pow(ulong number, ulong exponent) {
            ulong result = 1;
            while (exponent != 0) {
                if ((exponent & 1) == 1)
                    result *= number;
                number *= number;
                exponent >>= 1;
            }
            return result;
        }
        private ulong PowModulo(ulong number, ulong exponent, ulong modulo) {
            ulong result = 1;
            for (ulong i = 0; i < exponent; i++)
                result = (result * number) % modulo;
            return result;
        }
        private ulong FastPowModulo_BeCareful(ulong number, ulong exponent, ulong modulo) {
            // Doesn't work if (*) overflows 64 bits
            // when computing power of 2, result will be 0
            // otherwise, result is unpredictable
            ulong result = 1;
            while (exponent != 0) {
                if ((exponent & 1) == 1)
                    result = (result * number) % modulo;
                number = (number * number) % modulo; // (*)
                exponent >>= 1;
            }
            return result;
        }
        private void MulDigitsNumber(ulong[] digits, ref ulong digitsCount, ulong multiplier) {
            ulong carry = 0;
            for (ulong i = 0; i < digitsCount; i++) {
                carry += digits[i] * multiplier;
                digits[i] = carry % 10;
                carry /= 10;
            }
            while (carry > 0) {
                digits[digitsCount++] = carry % 10;
                carry /= 10;
            }
        }
        private bool IsPermutation(ulong a, ulong b) {
            // TODO: optimize this
            string aStr = a.ToString();
            string bStr = b.ToString();
            if (aStr.Length != bStr.Length)
                return false;
            char[] aArray = aStr.ToCharArray();
            Array.Sort(aArray);
            char[] bArray = bStr.ToCharArray();
            Array.Sort(bArray);
            for (int i = 0; i < aArray.Length; i++)
                if (aArray[i] != bArray[i])
                    return false;
            return true;
        }
        //private ulong Phi(bool[] sieve, ulong n) {
        //    if (!sieve[n])
        //        return n - 1;
        //    ulong limit = n / 2;
        //    ulong phiN = n;
        //    for (ulong j = 2; j <= limit; j++)
        //        if (!sieve[j] && (0 == (n % j)))
        //            phiN = (phiN * (j - 1)) / j;
        //    return phiN;
        //}
        //private ulong Phi(bool[] sieve, ulong n) {
        //    if (!sieve[n])
        //        return n - 1;
        //    if (n == 1 || n == 2)
        //        return 1;
        //    ulong sieveLimit = (ulong)sieve.Length;
        //    ulong phi = n;
        //    ulong i = 2;
        //    ulong lastPrime = 2;
        //    while (i < sieveLimit) {
        //        if (!sieve[i]) {
        //            lastPrime = i;
        //            if (0 == (n % i)) {
        //                phi -= phi / lastPrime;
        //                while (0 == (n % lastPrime))
        //                    n /= lastPrime;
        //            }
        //        }
        //        if (lastPrime * lastPrime > n)
        //            break;
        //        i++;
        //    }
        //    if (n > 1)
        //        phi -= phi / n;
        //    return phi;
        //}
        private ulong SumFactorialDigits(ulong number) {
            ulong sum = 0;
            while (number >= 1) {
                sum += Factorials10[number % 10];
                number /= 10;
            }
            return sum;
        }
        private bool IsPerfectSquare(ulong n) {
            // TODO: if (n and 7) = 1 or (n and 31) = 4 or (n and 127) = 16 or (n and 191) = 0 then print n "is probably square" else print n "is definitely not square".   http://en.wikipedia.org/wiki/Square_number#Properties
            //http://www.johndcook.com/blog/2008/11/17/fast-way-to-test-whether-a-number-is-a-square/
            ulong h = n & 0xF; // last hexidecimal "digit"
            if (h > 9)
                return false; // return immediately in 6 cases out of 16.

            // Take advantage of Boolean short-circuit evaluation
            if (h != 2 && h != 3 && h != 5 && h != 6 && h != 7 && h != 8) {
                ulong t = (ulong)(Math.Sqrt((double)n) + 0.5d);
                return t * t == n;
            }
            return false;
        }
        private ulong MakePalindrom(ulong n, ulong baseToUse, bool fOddLength) {
            ulong res = n;
            if (fOddLength)
                n /= baseToUse;
            while (n > 0) {
                res = (res * baseToUse) + (n % baseToUse);
                n /= baseToUse;
            }
            return res;
        }
        private int CompareNumberAsString(string a, string b) {
            if (a.Length < b.Length)
                return -1;
            else if (a.Length > b.Length)
                return +1;
            else
                return String.Compare(a, b);
        }
        // Solve a*lastX + b*lastY = 1
        private long ExtendedPGCD(long a, long b, out long lastX, out long lastY) {
            long x = 0;
            long y = 1;
            lastX = 1;
            lastY = 0;
            while (0 != b) {
                long tmp;
                long q = a / b;

                tmp = a;
                a = b;
                b = tmp % b;

                tmp = x;
                x = lastX - q * x;
                lastX = tmp;

                tmp = y;
                y = lastY - q * y;
                lastY = tmp;
            }
            return a;
        }
        private bool IsSpecialSet(ulong[] set) {
            int max = 1 << set.Length;
            for (int a = 1; a < max; a++)
                for (int b = 1; b < max; b++) { // check all bit patterns
                    if ((a & b) != 0)
                        continue; // not disjoint

                    int bitCount;
                    int pos;
                    int include;
                    ulong total;

                    // sum and count number of elements in sub-set A
                    bitCount = 0;
                    total = 0;
                    pos = 0;
                    include = a;
                    while (include > 0) {
                        if ((include & 1) != 0) {
                            total += set[pos];
                            bitCount++;
                        }
                        pos++;
                        include >>= 1;
                    }
                    ulong sumA = total;
                    int countA = bitCount;

                    // sum and count number of elements in sub-set B
                    bitCount = 0;
                    total = 0;
                    pos = 0;
                    include = b;
                    while (include > 0) {
                        if ((include & 1) != 0) {
                            total += set[pos];
                            bitCount++;
                        }
                        pos++;
                        include >>= 1;
                    }
                    ulong sumB = total;
                    int countB = bitCount;

                    // Check special set properties
                    if (sumA == sumB)
                        return false;
                    if ((countA > countB) && (sumA <= sumB))
                        return false;
                    if ((countA < countB) && (sumA >= sumB))
                        return false;
                }
            return true;
        }
        private string[] Permutations(string digits) {
            int n = 1;
            for (int i = 1; i <= digits.Length; i++)
                n *= i;
            String[] result = new String[n];
            if (n == 1) {
                result[0] = digits;
                return result;
            }
            for (int i = 0; i < digits.Length; i++) {
                String digitsSub = digits.Substring(0, i) + digits.Substring(i + 1);
                String[] resultSub = Permutations(digitsSub);
                for (int j = 0; j < resultSub.Length; j++)
                    result[i * resultSub.Length + j] = digits[i] + resultSub[j];
            }
            return result;
        }
        #endregion

        #region Problem 1
        public ulong Problem1() {
            // sum(i:1->n,i) = n*(n+1)/2  (triangle number)
            // multiple of 3 = 3*sum(i:1->n/3,i)
            // multiple of 5 = 5*sum(i:1->n/5,i)
            // must substract multiple of 15 = 15*sum(i:1->n/15,i)
            const ulong limit = 999;
            return 3 * Triangle(limit / 3) + 5 * Triangle(limit / 5) - 15 * Triangle(limit / 15);
        }
        #endregion
        #region Problem 2
        public ulong Problem2() {
            // Fn = Fn-1 + Fn-2
            const ulong limit = 4000000;
            ulong Fn_2 = 1;
            ulong Fn_1 = 1;
            ulong sum = 0;
            while (true) {
                ulong Fn = Fn_1 + Fn_2;
                if (Fn >= limit)
                    break;
                if ((Fn & 1) == 0)
                    sum += Fn;
                Fn_2 = Fn_1;
                Fn_1 = Fn;
            }
            return sum;
        }
        #endregion
        #region Problem 3
        public ulong Problem3() {
            const ulong number = 600851475143;
            ulong sqrtN = (ulong)(Math.Sqrt(number) + 0.5);
            if (0 == (sqrtN & 1))
                sqrtN++; // we want an odd number
            ulong result = 0;
            for (ulong i = sqrtN; i > 2; i -= 2)
                if (0 == (number % i))
                    if (IsPrime(i)) {
                        result = i;
                        break;
                    }
            return result;

            //ulong number = 600851475143;
            //ulong maxFactor = (ulong)(Math.Sqrt(number) + 0.5);
            //ulong factor = 3; // Don't need to treat 2, number is not divisible by 2
            //ulong lastFactor = 0;
            //while (number > 1 && factor <= maxFactor) {
            //    if (0 == (number % factor)) {
            //        number /= factor;
            //        lastFactor = factor;
            //        while (0 == (number % factor))
            //            number /= factor;
            //        maxFactor = (ulong)(Math.Sqrt(number) + 0.5);
            //    }
            //    factor += 2; // odd number
            //}
            //if (1 == number)
            //    return lastFactor;
            //else
            //    return number;
        }
        #endregion
        #region Problem 4
        public ulong Problem4() {
            // product of the 3-digits number is a 6-digits number
            // must be a palindrom, so digits will be: abccba
            // a*10^5+b*10^4+c+10^3+c*10^2+b*10^1+a*10^0
            // a*100001 + b*10010 + c*1100
            // 11*(a*9091 + b*910 + c*100) = m*n    so m or n must be divisible by 11
            // a cannot be 0
            ulong result = 0;
            for (ulong m = 999; m >= 100; m--)
                for (ulong n = 990; n >= 100; n -= 11) {
                    ulong product = m * n;
                    if (IsPalindromic(product, 10))
                        if (product > result)
                            result = product;
                }
            return result;
        }
        #endregion
        #region Problem 5
        public ulong Problem5() {
            //ulong result = 2 * 3 * 5 * 7 * 9 * 11 * 13 * 17 * 19; // start with the product of the first prime
            //while (true) {
            //    bool fOk = true;
            //    for (ulong i = 11; i <= 20; i++) // if divisible by number between 11 and 20, divisible by 2 to 10
            //        if (0 != (result % i)) {
            //            fOk = false;
            //            break;
            //        }
            //    if (fOk)
            //        break;
            //    result += 2; // must be even
            //}
            //return result;

            // 1 = 1^1          2 = 2^1
            // 3 = 3^1          4 = 2^2
            // 5 = 5^1          6 = 2^1*3^1
            // 7 = 7^1          8 = 2^3
            // 9 = 3^2          10 = 2^1*5^1
            // 11 = 11^1        12 = 2^2*3^1
            // 13 = 13^1        14 = 2^1*7^1
            // 15 = 3^1*5^1     16 = 2^4
            // 17 = 17^1        18 = 2^1*3^2
            // 19 = 19^1        20 = 2^2*5^1
            // result = product of every prime with highest exponent
            return Pow(2, 4) * Pow(3, 2) * 5 * 7 * 11 * 13 * 17 * 19;
        }
        #endregion
        #region Problem 6
        public ulong Problem6() {
            // sum(i:1->n,i)^2 = (n*(n+1)/2)^2 = n^2*(n+1)^2 /4 
            // sum(i:1->n,i^2) = n*(n+1)*(2*n+1)/6 
            const ulong limit = 100;
            const ulong sumSquared = (limit * limit * (limit + 1) * (limit + 1)) / 4;
            const ulong sumSquare = (limit * (limit + 1) * (2 * limit + 1)) / 6;
            return sumSquared - sumSquare;
        }
        #endregion
        #region Problem 7
        public ulong Problem7() {
            const ulong count = 10001;
            ulong n = 3;
            ulong primeCount = 1; // 2 is a prime
            while (true) {
                if (IsPrime(n)) {
                    primeCount++;
                    if (primeCount == count)
                        return n;
                }
                n += 2; // odd
            }
        }
        #endregion
        #region Problem 8
        public ulong Problem8() {
            const string number = "73167176531330624919225119674426574742355349194934" +
"96983520312774506326239578318016984801869478851843" +
"85861560789112949495459501737958331952853208805511" +
"12540698747158523863050715693290963295227443043557" +
"66896648950445244523161731856403098711121722383113" +
"62229893423380308135336276614282806444486645238749" +
"30358907296290491560440772390713810515859307960866" +
"70172427121883998797908792274921901699720888093776" +
"65727333001053367881220235421809751254540594752243" +
"52584907711670556013604839586446706324415722155397" +
"53697817977846174064955149290862569321978468622482" +
"83972241375657056057490261407972968652414535100474" +
"82166370484403199890008895243450658541227588666881" +
"16427171479924442928230863465674813919123162824586" +
"17866458359124566529476545682848912883142607690042" +
"24219022671055626321111109370544217506941658960408" +
"07198403850962455444362981230987879927244284909188" +
"84580156166097919133875499200524063689912560717606" +
"05886116467109405077541002256983155200055935729725" +
"71636269561882670428252483600823257530420752963450";

            ulong max = 0;
            for (int i = 0; i < number.Length - 5; i++) {
                ulong current = ToUInt64(number[i]) * ToUInt64(number[i + 1]) * ToUInt64(number[i + 2]) * ToUInt64(number[i + 3]) * ToUInt64(number[i + 4]);
                if (current > max)
                    max = current;
            }
            return max;
        }
        #endregion
        #region Problem 9
        public ulong Problem9() {
            for (ulong a = 1; a < 500; a++)
                for (ulong b = 1; b < 500; b++)
                    // a^2 + b^2 = c^2
                    // a + b + c = 1000
                    if (a * a + b * b == (1000 - a - b) * (1000 - a - b))
                        return a * b * (1000 - a - b);
            return 0;
        }
        #endregion
        #region Problem 10
        public ulong Problem10() {
            const ulong limit = 2000000;
            bool[] sieves = BuildSieve(limit);
            ulong sum = 0;
            for (ulong i = 2; i < limit; i++)
                if (!sieves[i])
                    sum += i;
            return sum;
        }
        #endregion
        #region Problem 11
        public ulong Problem11() {
            using (System.IO.StreamReader reader = new System.IO.StreamReader(@"..\..\..\square_11.txt")) {
                ulong[,] matrix = new ulong[20, 20];
                int i = 0;
                while (!reader.EndOfStream) {
                    string s = reader.ReadLine();
                    string[] numbers = s.Split(' ');
                    int j = 0;
                    foreach (string number in numbers)
                        matrix[i, j++] = Convert.ToUInt64(number);
                    i++;
                }

                ulong bestProduct = 0;
                for (int r = 0; r < 20; r++)
                    for (int c = 0; c < 20; c++) {
                        ulong product = 0;
                        if (c < 17) {
                            // Right and "Left"
                            product = matrix[r, c] * matrix[r, c + 1] * matrix[r, c + 2] * matrix[r, c + 3];
                            if (bestProduct < product)
                                bestProduct = product;
                        }

                        if (r < 17) {
                            // Down and "Up"
                            product = matrix[r, c] * matrix[r + 1, c] * matrix[r + 2, c] * matrix[r + 3, c];
                            if (bestProduct < product)
                                bestProduct = product;

                            // Diagonally, down to the right
                            if (c < 17) {
                                product = matrix[r, c] * matrix[r + 1, c + 1] * matrix[r + 2, c + 2] * matrix[r + 3, c + 3];
                                if (bestProduct < product)
                                    bestProduct = product;
                            }

                            // Diagonally, down to the left
                            if (c > 3) {
                                product = matrix[r, c] * matrix[r + 1, c - 1] * matrix[r + 2, c - 2] * matrix[r + 3, c - 3];
                                if (bestProduct < product)
                                    bestProduct = product;
                            }
                        }
                    }
                return bestProduct;
            }
        }
        #endregion
        #region Problem 12
        public ulong Problem12() {
            UInt32 position = 2;
            ulong triangle = 1; // First triangle number
            while (true) {
                int divisorCount = 0; // Count divisor
                int sqrtN = (int)Math.Sqrt(triangle);
                for (UInt32 j = 1; j <= sqrtN; j++)
                    if (0 == (triangle % j))
                        divisorCount += 2;
                if (divisorCount > 500) // Stop when 500 divisors are found
                    break;
                triangle += position; // Next triangle number
                position++;
            }
            return triangle;
        }
        #endregion
        #region Problem 13
        public ulong Problem13() {
            string[] numbers = { "37107287533902102798797998220837590246510135740250",
"46376937677490009712648124896970078050417018260538",
"74324986199524741059474233309513058123726617309629",
"91942213363574161572522430563301811072406154908250",
"23067588207539346171171980310421047513778063246676",
"89261670696623633820136378418383684178734361726757",
"28112879812849979408065481931592621691275889832738",
"44274228917432520321923589422876796487670272189318",
"47451445736001306439091167216856844588711603153276",
"70386486105843025439939619828917593665686757934951",
"62176457141856560629502157223196586755079324193331",
"64906352462741904929101432445813822663347944758178",
"92575867718337217661963751590579239728245598838407",
"58203565325359399008402633568948830189458628227828",
"80181199384826282014278194139940567587151170094390",
"35398664372827112653829987240784473053190104293586",
"86515506006295864861532075273371959191420517255829",
"71693888707715466499115593487603532921714970056938",
"54370070576826684624621495650076471787294438377604",
"53282654108756828443191190634694037855217779295145",
"36123272525000296071075082563815656710885258350721",
"45876576172410976447339110607218265236877223636045",
"17423706905851860660448207621209813287860733969412",
"81142660418086830619328460811191061556940512689692",
"51934325451728388641918047049293215058642563049483",
"62467221648435076201727918039944693004732956340691",
"15732444386908125794514089057706229429197107928209",
"55037687525678773091862540744969844508330393682126",
"18336384825330154686196124348767681297534375946515",
"80386287592878490201521685554828717201219257766954",
"78182833757993103614740356856449095527097864797581",
"16726320100436897842553539920931837441497806860984",
"48403098129077791799088218795327364475675590848030",
"87086987551392711854517078544161852424320693150332",
"59959406895756536782107074926966537676326235447210",
"69793950679652694742597709739166693763042633987085",
"41052684708299085211399427365734116182760315001271",
"65378607361501080857009149939512557028198746004375",
"35829035317434717326932123578154982629742552737307",
"94953759765105305946966067683156574377167401875275",
"88902802571733229619176668713819931811048770190271",
"25267680276078003013678680992525463401061632866526",
"36270218540497705585629946580636237993140746255962",
"24074486908231174977792365466257246923322810917141",
"91430288197103288597806669760892938638285025333403",
"34413065578016127815921815005561868836468420090470",
"23053081172816430487623791969842487255036638784583",
"11487696932154902810424020138335124462181441773470",
"63783299490636259666498587618221225225512486764533",
"67720186971698544312419572409913959008952310058822",
"95548255300263520781532296796249481641953868218774",
"76085327132285723110424803456124867697064507995236",
"37774242535411291684276865538926205024910326572967",
"23701913275725675285653248258265463092207058596522",
"29798860272258331913126375147341994889534765745501",
"18495701454879288984856827726077713721403798879715",
"38298203783031473527721580348144513491373226651381",
"34829543829199918180278916522431027392251122869539",
"40957953066405232632538044100059654939159879593635",
"29746152185502371307642255121183693803580388584903",
"41698116222072977186158236678424689157993532961922",
"62467957194401269043877107275048102390895523597457",
"23189706772547915061505504953922979530901129967519",
"86188088225875314529584099251203829009407770775672",
"11306739708304724483816533873502340845647058077308",
"82959174767140363198008187129011875491310547126581",
"97623331044818386269515456334926366572897563400500",
"42846280183517070527831839425882145521227251250327",
"55121603546981200581762165212827652751691296897789",
"32238195734329339946437501907836945765883352399886",
"75506164965184775180738168837861091527357929701337",
"62177842752192623401942399639168044983993173312731",
"32924185707147349566916674687634660915035914677504",
"99518671430235219628894890102423325116913619626622",
"73267460800591547471830798392868535206946944540724",
"76841822524674417161514036427982273348055556214818",
"97142617910342598647204516893989422179826088076852",
"87783646182799346313767754307809363333018982642090",
"10848802521674670883215120185883543223812876952786",
"71329612474782464538636993009049310363619763878039",
"62184073572399794223406235393808339651327408011116",
"66627891981488087797941876876144230030984490851411",
"60661826293682836764744779239180335110989069790714",
"85786944089552990653640447425576083659976645795096",
"66024396409905389607120198219976047599490197230297",
"64913982680032973156037120041377903785566085089252",
"16730939319872750275468906903707539413042652315011",
"94809377245048795150954100921645863754710598436791",
"78639167021187492431995700641917969777599028300699",
"15368713711936614952811305876380278410754449733078",
"40789923115535562561142322423255033685442488917353",
"44889911501440648020369068063960672322193204149535",
"41503128880339536053299340368006977710650566631954",
"81234880673210146739058568557934581403627822703280",
"82616570773948327592232845941706525094512325230608",
"22918802058777319719839450180888072429661980811197",
"77158542502016545090413245809786882778948721859617",
"72107838435069186155435662884062257473692284509516",
"20849603980134001723930671666823555245252804609722",
"53503534226472524250874054075591789781264330331690"};

            // Only the 11 first digit affect the resulting sum
            ulong sum = 0;
            foreach (string s in numbers) {
                ulong i = Convert.ToUInt64(s.Substring(0, 11));
                sum += i;
            }
            return Convert.ToUInt64(sum.ToString().Substring(0, 10));
        }
        #endregion
        #region Problem 14
        public ulong Problem14() {
            const ulong limit = 1000000;
            int[] lengths = new int[limit];
            for (ulong i = 0; i < limit; i++) lengths[i] = 0;
            int bestLength = 0;
            ulong longest = 0;
            for (ulong n = 2; n < limit; n++) {
                if (0 != lengths[n]) // Already computed, don't compute
                    continue;
                // Compute sequence
                List<ulong> sequence = new List<ulong>();
                ulong iterator = n;
                int baseLength = 0;
                sequence.Add(iterator);
                while (true) {
                    if (0 == (iterator & 1))
                        iterator >>= 1;
                    else
                        iterator = 3 * iterator + 1;
                    if (iterator < n) {
                        baseLength = lengths[iterator];
                        if (0 != baseLength)
                            break; // Already computed, stop
                    }
                    sequence.Add(iterator);
                    if (iterator == 1)
                        break;
                }
                // Add length foreach number below limit in the sequence
                for (int i = 0; i < sequence.Count; i++) {
                    ulong v = sequence[i];
                    if (v < limit) {
                        int length = sequence.Count - i + baseLength;
                        lengths[v] = length;
                        if (length > bestLength) {
                            bestLength = length;
                            longest = v;
                        }
                    }
                }
            }
            return longest;

            //ulong longest = 0;
            //ulong bestLength = 0;
            //for (ulong i = 2; i <= 1000000; i++) {
            //    ulong iterator = i;
            //    ulong length = 1;
            //    while (iterator != 1) {
            //        length++;
            //        if (length > bestLength) {
            //            bestLength = length;
            //            longest = i;
            //        }
            //        if ((iterator & 1) == 0)
            //            iterator /= 2;
            //        else
            //            iterator = 3 * iterator + 1;
            //    }
            //}
            //return longest;
        }
        #endregion
        #region Problem 15
        public ulong Problem15() {
            // 20 steps right and 20 steps down
            return 137846528820; // 2 * 13 * 2 * 37 * 11 * 31 * 29 * 9 * 5 * 23 * 7; // 40!/(20!*20!)
        }
        #endregion
        #region Problem 16
        public ulong Problem16() {
            const int power = 1000; // Log10(2^n) = n*Log10(2)
            int limit = (int)Math.Ceiling((double)power * Math.Log10(2)) + 1; // Number of digit + 1 for sentinel
            int[] digits = new int[limit];
            for (int i = 0; i < digits.Length; i++) digits[i] = 0;
            // digits[0] is used as sentinel
            digits[1] = 1;

            for (int i = 1; i <= power; i++) {
                for (int j = limit - 1; j > 0; j--) {
                    // If previous number is higher than 5, multiply it by 2 gives a number between 10 and 18, so 1 must be added to current
                    if (digits[j - 1] >= 5)
                        digits[j] = ((2 * digits[j]) % 10) + 1;
                    else
                        digits[j] = (2 * digits[j]) % 10;
                }
            }
            ulong sum = 0;
            foreach (int i in digits)
                sum += (ulong)i;
            return sum;
        }
        #endregion
        #region Problem 17
        private ulong _17_LettersOfNumber(ulong num, ulong[,] bases) {
            ulong count = 0;
            ulong tempnum;
            if (num == 1000)
                count = 11;
            else {
                tempnum = num % 100;
                if (tempnum < 20)
                    count += bases[tempnum, 0];
                else
                    count += bases[num % 10, 0] + bases[(num / 10) % 10, 1];
                if (num > 99)
                    count += bases[(num / 100), 0] + (ulong)(7 + ((tempnum == 0) ? 0 : 3));
            }
            return count;
        }
        public ulong Problem17() {
            ulong[,] bases = { {0, 0}, {3, 0}, {3, 6}, {5, 6}, {4, 5}, {4, 5}, {3, 5}, {5, 7}, 
                  {5, 6}, {4, 6}, {3, 0}, {6, 0}, {6, 0}, {8, 0}, {8, 0}, {7, 0},
                  {7, 0}, {9, 0}, {8, 0}, {8, 0} };
            ulong count = 0;
            for (ulong i = 1; i <= 1000; i++)
                count += _17_LettersOfNumber(i, bases);
            return count;
        }
        #endregion
        #region Problem 18
        public ulong Problem18() {
            using (System.IO.StreamReader reader = new System.IO.StreamReader(@"..\..\..\triangle_18.txt")) {
                List<List<ulong>> triangle = new List<List<ulong>>();
                while (!reader.EndOfStream) {
                    string s = reader.ReadLine();
                    string[] numbers = s.Split(' ');
                    List<ulong> list = new List<ulong>();
                    foreach (string number in numbers)
                        list.Add(Convert.ToUInt64(number));
                    triangle.Add(list);
                }

                // Bottom-up approach, each number n at index i in line l is replaced by max( n+nl[i], n+nl[i+1] ) with nl = next line
                for (int l = triangle.Count - 2; l >= 0; l--) {
                    List<ulong> nextLine = triangle[l + 1];
                    List<ulong> line = triangle[l];
                    for (int i = 0; i < line.Count; i++) {
                        ulong sum1 = line[i] + nextLine[i];
                        ulong sum2 = line[i] + nextLine[i + 1];
                        line[i] = Math.Max(sum1, sum2);// sum1 > sum2 ? sum1 : sum2;
                    }
                }
                return triangle[0][0];
            }
        }
        #endregion
        #region Problem 19
        private bool _19_IsLeapYear(int year) {
            if (year % 400 == 0)
                return true;
            else if (year % 100 == 0)
                return false;
            else if (year % 4 == 0)
                return true;
            else
                return false;
        }
        public ulong Problem19() {
            ulong count = 0;
            int[] monthDays = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
            int weekday = 1;
            for (int year = 1900; year <= 2000; year++)
                for (int month = 1; month <= 12; month++) {
                    int daysCount = monthDays[month - 1];
                    if (month == 2 && _19_IsLeapYear(year))
                        daysCount++;
                    if (year >= 1901 && weekday == 7)
                        count++;
                    weekday = 1 + ((weekday + daysCount) % 7);
                }
            return count;
            //ulong count = 0;
            //DateTime date = new DateTime(1901, 1, 1);
            //while (date.Year != 2000 || date.Month != 12 || date.Day != 1) {
            //    if (date.DayOfWeek == DayOfWeek.Sunday && date.Day == 1)
            //        count++;
            //    date = date.AddDays(1);
            //}
            //return count;
        }
        #endregion
        #region Problem 20
        public ulong Problem20() {
            //int limit = 100;
            //BigInt number = 1;
            //for (int i = 2; i < limit; i++)
            //    number *= i;
            //return SumDigits(number.ToString());

            // n! <= e*((n+1)/e)^(n+1)
            const ulong limit = 100;
            int limitDigitsCount = (int)Math.Ceiling(Math.Log10(Math.E * Math.Pow((double)(limit + 1) / Math.E, limit + 1)));
            // or (int)Math.Ceiling((double)(limit + 1) * Math.Log10(limit + 1) - (double)limit * Math.Log10(Math.E));
            ulong[] digits = new ulong[limitDigitsCount + 1];
            for (int i = 0; i < limitDigitsCount; i++) digits[i] = 0;

            digits[0] = 1;
            ulong digitCount = 1;
            for (ulong i = 2; i <= limit; i++) {
                MulDigitsNumber(digits, ref digitCount, i);
                //ulong toto = 0;
                //foreach (ulong digit in digits)
                //    toto += digit;
                //Console.WriteLine(i + "->" + toto);
            }

            ulong sum = 0;
            foreach (ulong digit in digits)
                sum += digit;
            return sum;
        }
        #endregion
        #region Problem 21
        public ulong Problem21() {
            //ulong sum = 0;
            //for (ulong a = 2; a <= 9999; a++) {
            //    ulong b = SumOfProperDivisors(a);
            //    if (b > a) {
            //        ulong c = SumOfProperDivisors(b);
            //        if (a == c)
            //            sum = sum + a + b;
            //    }
            //}
            //return sum;
            const ulong limit = 10000;
            bool[] sieve = BuildSieve(limit);
            ulong sum = 0;
            for (ulong i = 10; i < limit; i++) {
                if (sieve[i]) {
                    ulong factorSum = SumOfProperDivisors(i);
                    ulong amicableFactorSum = SumOfProperDivisors(factorSum);
                    if (factorSum != amicableFactorSum && i == amicableFactorSum)
                        sum = sum + (ulong)i;
                }
            }
            return sum;
        }
        #endregion
        #region Problem 22
        public ulong Problem22() {
            using (System.IO.StreamReader reader = new System.IO.StreamReader(@"..\..\..\names.txt")) {
                string fileContent = reader.ReadToEnd();
                List<string> names = new List<string>(fileContent.Split(','));
                names.Sort();
                ulong sum = 0;
                for (int i = 0; i < names.Count; i++) {
                    ulong nameValue = 0;
                    foreach (char c in names[i])
                        if (c != '"')
                            nameValue += Convert.ToUInt64(c) - 64;
                    sum += nameValue * ((ulong)i + 1);
                }
                return sum;
            }
        }
        #endregion
        #region Problem 23
        public ulong Problem23() {
            const ulong limit = 28123;
            // Get list of abundants
            List<ulong> abundants = new List<ulong>();
            for (ulong i = 12; i <= limit; i++) {
                ulong sum = SumOfDivisors(i);
                if (sum > 2 * i)
                    abundants.Add(i);
            }
            // Compute every combination of sum of 2 abundants
            bool[] check = new bool[limit + 1];
            for (ulong i = 0; i <= limit; i++) check[i] = false;
            foreach (ulong i in abundants)
                foreach (ulong j in abundants) {
                    ulong sum = i + j;
                    if (sum <= limit)
                        check[sum] = true;
                }
            // Sum numbers not equal to sum of 2 abundants
            ulong uncheckedSum = 0;
            for (int i = (int)limit; i >= 0; i--)
                if (!check[i])
                    uncheckedSum += (ulong)i;
            return uncheckedSum;
        }
        #endregion
        #region Problem 24
        public ulong Problem24() {
            //string[] permutations = Permutations("0123456789");
            //return Convert.ToUInt64(permutations[999999]);

            //999999 = 2*9! + 274239 -> 2nd digit
            //274239 = 6*8! + 32319  -> 6th digit
            //...
            string digits = "0123456789"; // permutation 0
            string result = "";
            ulong n = 999999;
            for (ulong i = 9; i >= 1; i--) {
                ulong fact = Factorial(i);
                ulong quotient = n / fact;
                n = n % fact;
                result += digits[(int)quotient];
                digits = digits.Substring(0, (int)quotient) + digits.Substring((int)quotient + 1);
            }
            return Convert.ToUInt64(result + digits);
        }
        #endregion
        #region Problem 25
        public ulong Problem25() {
            //uint digits = 1000;
            //BigInt thousandDigits = BigInt.Power(10, digits-1);
            //BigInt Fn = 1;
            //BigInt Fn1 = 1;
            //int term = 1;
            //while (Fn < thousandDigits) {
            //    BigInt Fn2 = Fn + Fn1;
            //    Fn = Fn1;
            //    Fn1 = Fn2;
            //    term++;
            //}
            //return term;

            // phi = (1+sqrt(5))/2
            // Fn = Round( phi^n / sqrt(5) )  with n greater enough
            // 1000 digits ==> Log10(Fn) = 999
            // Log10( phi^n / sqrt(5) ) = 999
            // Log10( phi^n ) - Log10(5) = 999
            // n*Log10(phi) = 999 + Log10( sqrt(5) )
            // n = ( 999 + Log10( sqrt(5) ) ) / Log10( phi )
            return (ulong)Math.Round((999.0 + Math.Log10(Math.Sqrt(5))) / Math.Log10((1.0 + Math.Sqrt(5)) / 2.0));
        }
        #endregion
        #region Problem 26
        public ulong Problem26() {
            ulong longest = 1;
            int length = 1;
            for (ulong i = 3; i <= 1000; i++) {
                ulong dividend = 1;
                ulong divisor = i;
                List<ulong> remainders = new List<ulong>();
                // Manual division
                while (true) {
                    while (dividend < divisor)
                        dividend *= 10;
                    ulong remainder = dividend % divisor;
                    if (0 == remainder)
                        break;
                    //int quotient = dividend / divisor;
                    if (remainders.Contains(remainder))
                        break;
                    remainders.Add(remainder);
                    dividend = remainder;
                }
                if (remainders.Count > length) {
                    length = remainders.Count;
                    longest = i;
                }
            }
            return longest;
        }
        #endregion
        #region Problem 27
        public long Problem27() {
            bool[] sieve = BuildSieve(1000 * 1000 + 1000 * 1000 + 1000);
            int bestCount = 0;
            long bestA = 0;
            long bestB = 0;
            for (long a = -1000; a <= 1000; a++) {
                if (a == 0)
                    continue;
                for (long b = -1000; b <= 1000; b++) {
                    if (b == 0)
                        continue;
                    int count = 0;
                    for (long n = 0; n < Math.Abs(a); n++) { // !! should test if primes are consecutive
                        long number = n * n + a * n + b;
                        if (number > 0 && !sieve[number])
                            count++;
                        else
                            break;
                    }
                    if (count > bestCount) {
                        bestA = a;
                        bestB = b;
                        bestCount = count;
                    }
                }
            }
            return bestA * bestB;
        }
        #endregion
        #region Problem 28
        //private ulong _28_Sub(ulong n) {
        //    if (n == 1)
        //        return 1;
        //    else {
        //        ulong increment = n * n;
        //        ulong sum = 0;
        //        for (int i = 0; i < 4; i++) {
        //            sum += increment;
        //            increment -= (n - 1);
        //        }
        //        return sum + _28_Sub(n - 2);
        //    }
        //}
        public ulong Problem28() {
            // square side 3 = square side 1 + [ 3 + 5 + 7 + 9 ]
            // square side 5 = square side 3 + [ 13 + 17 + 21 + 25 ]
            // square side 7 = square side 5 + [ 31 + 37 + 43 + 49 ]
            //return _28_Sub(1001);

            // Corners: n^2-3n+3, n^2-2n+2, n^2-n+1, n^2
            // Sum: 4n^2-6n+6
            ulong sum = 1;
            for (ulong i = 3; i <= 1001; i += 2)
                sum += 4 * i * i - 6 * i + 6;
            return sum;
        }
        #endregion
        #region Problem 29
        public ulong Problem29() {
            List<double> distinct = new List<double>();
            for (int a = 2; a <= 100; a++)
                for (int b = 2; b <= 100; b++) {
                    double pow = Math.Pow(a, b); // no precision problem, lucky us
                    if (!distinct.Contains(pow))
                        distinct.Add(pow);
                }
            return (ulong)distinct.Count;
        }
        #endregion
        #region Problem 30
        public ulong Problem30() {
            // UpperBound: 6*9^5  any six-digit larger than 6*9^5 cannot have a digit-power-sum larger than this
            ulong sum = 0;
            for (ulong i = 2; i <= 6 * 9 * 9 * 9 * 9 * 9; i++) {
                string s = i.ToString();
                ulong digitPowerSum = 0;
                foreach (char c in s) {
                    ulong digit = ToUInt64(c);
                    digitPowerSum += digit * digit * digit * digit * digit;
                }
                if (digitPowerSum == i)
                    sum += i;
            }
            return sum;
        }
        #endregion
        #region Problem 31
        public ulong Problem31() {
            //1p, 2p, 5p, 10p, 20p, 50p, £1 (100p) and £2 (200p)
            //total 200p

            //200=200*a+100*b+50*c+20*d+10*e+5*f+2*g+1*h
            ulong count = 0;
            int a, b, c, d, e, f, g;
            for (a = 200; a >= 0; a -= 200)
                for (b = a; b >= 0; b -= 100)
                    for (c = b; c >= 0; c -= 50)
                        for (d = c; d >= 0; d -= 20)
                            for (e = d; e >= 0; e -= 10)
                                for (f = e; f >= 0; f -= 5)
                                    for (g = f; g >= 0; g -= 2)
                                        count++;
            return count;
        }
        #endregion
        #region Problem 32
        public ulong Problem32() {
            // #digits multiplicand + #digits multiplier + #digits product = 9 digits
            // 1 digit * 4 digits = 4 digits (9 digits)
            // 2 digits * 3 digits = 4 or 5 digits (9 digits or 10 digits)
            List<int> panDigitalProducts = new List<int>();
            for (int a = 2; a <= 98; a++) {
                int start = (a >= 10) ? 123 : 1234;
                for (int b = start; b <= (10000 / a) + 1; b++) {
                    int product = a * b;
                    string s = a.ToString() + b.ToString() + product.ToString();
                    if (s.Length == 9) {
                        bool fIsPanDigitalProduct = IsPandigital(s);
                        if (fIsPanDigitalProduct && !panDigitalProducts.Contains(product))
                            panDigitalProducts.Add(product);
                    }
                }
            }
            ulong sum = 0;
            foreach (int panDigitalProduct in panDigitalProducts)
                sum += (ulong)panDigitalProduct;
            return sum;
        }
        #endregion
        #region Problem 33
        private void _33_SimplifyFraction(ulong numerator, ulong denominator, out ulong simplifiedNumerator, out ulong simplifiedDenominator) {
            ulong pgcd = PGCD(numerator, denominator);
            simplifiedNumerator = numerator / pgcd;
            simplifiedDenominator = denominator / pgcd;
        }
        public ulong Problem33() {
            ulong lowerBound = 10;
            ulong upperBound = 99;
            List<KeyValuePair<ulong, ulong>> curiousFractions = new List<KeyValuePair<ulong, ulong>>();
            for (ulong numerator = lowerBound; numerator <= upperBound; numerator++) { // 2 digits
                for (ulong denominator = numerator + 1; denominator <= upperBound; denominator++) { // 2 digits and num/den < 1
                    if ((0 != numerator % 10) || (0 != denominator % 10)) { // non-trivial
                        string numeratorAsString = numerator.ToString();
                        string denominatorAsString = denominator.ToString();
                        bool fFound = false;
                        for (int i = 0; i < numeratorAsString.Length && !fFound; i++)
                            for (int j = 0; j < denominatorAsString.Length && !fFound; j++)
                                if (numeratorAsString[i] == denominatorAsString[j]) {
                                    ulong reducedNumerator = Convert.ToUInt64(numeratorAsString.Clone().ToString().Remove(i, 1));//ToUInt64(numeratorAsString[1 - i]); // Only 2 characters, no substring needed
                                    ulong reducedDenominator = Convert.ToUInt64(denominatorAsString.Clone().ToString().Remove(j, 1));//ToUInt64(denominatorAsString[1 - j]); // Only 2 characters, no substring needed
                                    if (0 != reducedDenominator) {
                                        ulong simplifiedReducedNumerator, simplifiedReducedDenominator;
                                        _33_SimplifyFraction(reducedNumerator, reducedDenominator, out simplifiedReducedNumerator, out simplifiedReducedDenominator);
                                        ulong simplifiedNumerator, simplifiedDenominator;
                                        _33_SimplifyFraction(numerator, denominator, out simplifiedNumerator, out simplifiedDenominator);
                                        if (simplifiedReducedNumerator == simplifiedNumerator && simplifiedReducedDenominator == simplifiedDenominator) {
                                            curiousFractions.Add(new KeyValuePair<ulong, ulong>(numerator, denominator));
                                            fFound = true;
                                        }
                                    }
                                }
                    }
                }
            }
            ulong productNumerator = 1;
            ulong productDenominator = 1;
            foreach (KeyValuePair<ulong, ulong> kv in curiousFractions) {
                productNumerator *= kv.Key;
                productDenominator *= kv.Value;
            }
            ulong simplifiedProductNumerator, simplifiedProductDenominator;
            _33_SimplifyFraction(productNumerator, productDenominator, out simplifiedProductNumerator, out simplifiedProductDenominator);
            return simplifiedProductDenominator;
        }
        #endregion
        #region Problem 34
        public ulong Problem34() {
            // n*9! = max sum of digit factorial
            // (10^n)-1 = max number with n digits
            // n*9! >= (10^n)-1
            // n    n*9!        (10^n)-1
            // 5    1814400     99999       OK
            // 6    2177288     999999      OK
            // 7    2540160     9999999     KO
            ulong limit = 7 * Factorials10[9];
            ulong sum = 0;
            for (ulong n = 3; n <= limit; n++) {
                ulong sumFactorialDigits = SumFactorialDigits(n);
                if (n == sumFactorialDigits)
                    sum += n;
            }
            return sum;
        }
        #endregion
        #region Problem 35
        public ulong Problem35() {
            // Optimisation, consider number with 1, 3, 7, 9 as digit -> number ending with 2, 4, 5, 6, 8 are not prime (except 2 and 5)
            const ulong limit = 1000000;
            ulong count = 4; // 2, 3, 5, 7 are circular prime
            for (ulong i = 10; i < limit; i++) {
                // circular prime: 197 -> 971 -> 719 are all primes
                string s = Convert.ToString(i);
                bool fOk = true;
                for (int j = 0; j < s.Length; j++) {
                    // If digit is not 1, 3, 7, 9 reject number
                    if (s[0] != '1' && s[0] != '3' && s[0] != '7' && s[0] != '9') {
                        fOk = false;
                        break;
                    }
                    ulong n = Convert.ToUInt64(s);
                    if (!IsPrime(n)) {
                        fOk = false;
                        break;
                    }
                    s = s.Substring(1) + s[0];
                }
                if (fOk)
                    count++;
            }
            return count;
        }
        #endregion
        #region Problem 36
        public ulong Problem36() {
            //ulong sum = 0;
            //for (int n = 1; n <= 1000000; n+=2) { // no ending 0 in base 2
            //    if (0 != (n % 10)) { // no ending 0 in base 10
            //        bool fIsPalindromicBase10 = IsPalindromic(n, 10);
            //        bool fIsPalindromicBase2 = IsPalindromic(n, 2);
            //        if (fIsPalindromicBase10 && fIsPalindromicBase2)
            //            sum += (ulong)n;
            //    }
            //}
            //return sum;

            ulong sum = 0;
            for (int nBase10 = 1; nBase10 < 1000000; nBase10 += 2) { // no ending 0 in base 2
                if (0 != (nBase10 % 10)) { // no ending 0 in base 10
                    bool fOk = true;
                    string sBase10 = Convert.ToString(nBase10);
                    for (int i = 0; i < sBase10.Length / 2; i++)
                        if (sBase10[i] != sBase10[sBase10.Length - i - 1]) {
                            fOk = false;
                            break;
                        }
                    if (fOk) {
                        string sBase2 = Convert.ToString(nBase10, 2);
                        for (int i = 0; i < sBase2.Length / 2; i++)
                            if (sBase2[i] != sBase2[sBase2.Length - i - 1]) {
                                fOk = false;
                                break;
                            }
                    }
                    if (fOk)
                        sum += (ulong)nBase10;
                }
            }
            return sum;
        }
        #endregion
        #region Problem 37
        public ulong Problem37() {
            const ulong limit = 1000000; // arbitrary limit
            bool[] sieve = BuildSieve(limit);
            List<ulong> numbers = new List<ulong>();
            for (ulong n = 11; n < limit; n++) {
                if (!sieve[n]) {
                    bool fOk = true;
                    //string leftAsString = n.ToString();
                    //string rightAsString = (string)leftAsString.Clone();
                    //while (leftAsString.Length > 1) {
                    //    leftAsString = leftAsString.Substring(1);
                    //    int left = Convert.ToInt32(leftAsString);
                    //    if (sieve[left]) {
                    //        fOk = false;
                    //        break;
                    //    }
                    //    rightAsString = rightAsString.Substring(0, rightAsString.Length - 1);
                    //    int right = Convert.ToInt32(rightAsString);
                    //    if (sieve[right]) {
                    //        fOk = false;
                    //        break;
                    //    }
                    //}

                    ulong pow10 = 10;
                    while (true) {
                        ulong left = n / pow10;
                        if (sieve[left]) {
                            fOk = false;
                            break;
                        }
                        ulong right = n % pow10;
                        if (sieve[right]) {
                            fOk = false;
                            break;
                        }
                        pow10 *= 10;
                        if (left < 10)
                            break;
                    }

                    if (fOk)
                        numbers.Add(n);
                    if (11 == numbers.Count)
                        break;
                }
            }
            ulong sum = 0;
            foreach (int number in numbers)
                sum += (ulong)number;
            return sum;
        }
        #endregion
        #region Problem 38
        public ulong Problem38() {
            ulong product = 0;
            // upper bound is 9876 . 9876*2 = 987619752 (9 digits)
            // 12345 . 12345*2 = will have 10 digits
            ulong n = 9876;
            while (true) {
                string s = "";
                ulong next = n;
                for (ulong multiplier = 1; multiplier <= 9; multiplier++) {
                    s += next.ToString();
                    next = n * (multiplier + 1);
                    if (s.Length + next.ToString().Length > 9)
                        break;
                }
                if (IsPandigital(s)) {
                    product = Convert.ToUInt64(s);
                    break;
                }
                n--;
            }
            return product;
        }
        #endregion
        #region Problem 39
        public ulong Problem39() {
            // a^2+b^2=c^2 (1)
            // a+b+c=p -> c = p-a-b (2)
            // a+b>c  c>a  c>b
            // (2) in (1)
            // a^2+b^2 = (p-a-b)^2
            // a^2+b^2 = p^2+a^2+b^2-2ap-2pb+2ab
            // 2pb-2ab = p^2 - 2ap
            // 2b(p-a) = p(p-2a)
            // b = p(p-2a)/2(p-a)  must be integral
            const ulong limit = 1000;
            int maxSolutionCount = 0;
            ulong pWithMaxSolution = 0;
            for (ulong p = 1; p <= limit; p++) {
                int solutionCount = 0;
                for (ulong a = 1; a < p / 3; a++) { // force a to be the smallest side
                    ulong remainder = (p * (p - 2 * a)) % (2 * (p - a));
                    if (0 == remainder) {
                        solutionCount++;
                        if (solutionCount > maxSolutionCount) {
                            pWithMaxSolution = p;
                            maxSolutionCount = solutionCount;
                        }
                    }
                }
            }
            return pWithMaxSolution;
        }
        #endregion
        #region Problem 40
        public ulong Problem40() {
            //int limit = 1000000;
            //StringBuilder s = new StringBuilder();
            //int n = 1;
            //while (true) {
            //    s.Append(n);
            //    if (s.Length >= limit)
            //        break;
            //    n++;
            //}
            //int[] positions = { 0, 9, 99, 999, 9999, 99999, 999999 };
            //int product = 1;
            //foreach (int position in positions)
            //    product *= ToInt32(s[position]);
            //return product;

            const int limit = 1000000;
            int[] positions = { 1, 10, 100, 1000, 10000, 100000, 1000000 };
            ulong product = 1;
            int currentPos = 1;
            int positionsIndex = 0;
            int n = 1;
            while (true) {
                string s = n.ToString();
                int nextPos = currentPos + s.Length;
                if (nextPos >= limit)
                    break;
                // position we are looking for is between current and next, extract digit
                if (positions[positionsIndex] >= currentPos && positions[positionsIndex] < nextPos) {
                    int diff = positions[positionsIndex] - currentPos;
                    ulong digitAtPosition = ToUInt64(s[diff]);
                    product *= digitAtPosition;
                    positionsIndex++;
                }
                currentPos = nextPos;
                n++;
            }
            return product;
        }
        #endregion
        #region Problem 41
        public ulong Problem41() {
            // Optimisation: we can start with 7654321
            // Because if the digit-sum of number is divisible by 3 so is the number
            // and 9+8+7+6+5+4+3+2+1 = 45 (divisible by 3)
            // and 8+7+6+5+4+3+2+1 = 36 (divisible by 3)

            //ulong limit = 7654321;
            //for (ulong n = limit; n >= 2; n -= 2)
            //    if (IsPandigital(n.ToString()) && IsPrime(n))
            //        return n;
            //return 0;

            const string digits = "7654321";
            string[] permutations = Permutations(digits);
            foreach (string s in permutations) {
                ulong n = Convert.ToUInt64(s);
                if (IsPrime(n))
                    return n;
            }
            return 0;
        }
        #endregion
        #region Problem 42
        public ulong Problem42() {
            using (System.IO.StreamReader reader = new System.IO.StreamReader(@"..\..\..\words_42.txt")) {
                string s = reader.ReadToEnd();
                string[] words = s.Split(',');
                ulong count = 0;
                foreach (string word in words) {
                    ulong value = 0;
                    foreach (char c in word)
                        if (char.IsLetter(c))
                            value += Convert.ToUInt64(c) - 64;
                    if (IsTriangle(value))
                        count++;
                }
                return count;
            }
        }
        #endregion
        #region Problem 43
        public ulong Problem43() {
            // DOESNT WORK
            //// d0 <> 0
            //// d4 = {0, 2, 4, 6, 8}
            //// d6 = {5}  0 must be excluded because a sequence cannot start with 0
            //// d6d7d8 = { 506, 517, 528, 539, 561, 572, 583, 594 } multiple of 11 starting with 5
            //// d7d8d9 = { 286, 390, 728, 832 } multiple of 13 without 5
            //// d8d9d10 = { 289, 867, 901 } multiple of 17 without 5
            //// d6d7d8d9d10 = { 52867, 53901, 57289 } d6 = 5 and end of d7d8d9 must start d8d9d10
            //// d5d6d7 = { 357, 952 } multiple of 7 and ending with { 52, 53, 57 }
            //// d5d6d7d8d9d10 = { 357289, 952867 }
            //// d4 = { 0, 4, 6 } 2 and 8 are already found in d5->d10
            //// 9, 7, 8, 2, 5 not available for d1, d2, d3, d4

            bool[] digits = new bool[10];
            for (int i = 0; i < digits.Length; i++) digits[i] = false;
            ulong sum = 0;
            for (int d1 = 0; d1 < 10; d1++) {
                digits[d1] = true;
                for (int d2 = 0; d2 < 10; d2++) {
                    if (digits[d2]) continue;
                    digits[d2] = true;
                    for (int d3 = 0; d3 < 10; d3++) {
                        if (digits[d3]) continue;
                        digits[d3] = true;
                        for (int d4 = 0; d4 < 10; d4++) {
                            if (digits[d4]) continue;
                            if ((0 != (d4 & 1))) continue; // d2d3d4 divisible by 2
                            digits[d4] = true;
                            for (int d5 = 0; d5 < 10; d5++) {
                                if (digits[d5]) continue;
                                if (((100 * d3 + 10 * d4 + d5) % 3) != 0) continue; // d3d4d5 divisible by 3
                                digits[d5] = true;
                                for (int d6 = 0; d6 < 10; d6++) {
                                    if (digits[d6]) continue;
                                    if (d6 != 5 && d6 != 0) continue; // d4d5d6 divisible by 5
                                    digits[d6] = true;
                                    for (int d7 = 0; d7 < 10; d7++) {
                                        if (digits[d7]) continue;
                                        if (((100 * d5 + 10 * d6 + d7) % 7) != 0) continue;// d5d6d7 divisible by 7
                                        digits[d7] = true;
                                        for (int d8 = 0; d8 < 10; d8++) {
                                            if (digits[d8]) continue;
                                            if (((100 * d6 + 10 * d7 + d8) % 11) != 0) continue; // d6d7d8 divisible by 11
                                            digits[d8] = true;
                                            for (int d9 = 0; d9 < 10; d9++) {
                                                if (digits[d9]) continue;
                                                if (((100 * d7 + 10 * d8 + d9) % 13) != 0) continue; // d7d8d9 divisible by 13
                                                digits[d9] = true;
                                                for (int d10 = 0; d10 < 10; d10++) {
                                                    if (digits[d10]) continue;
                                                    if (((100 * d8 + 10 * d9 + d10) % 17) != 0) continue;// d8d9d10 divisible by 17
                                                    string concat = d1.ToString() + d2.ToString() + d3.ToString() + d4.ToString() + d5.ToString() + d6.ToString() + d7.ToString() + d8.ToString() + d9.ToString() + d10.ToString();
                                                    ulong n = Convert.ToUInt64(concat);
                                                    sum += n;
                                                }
                                                digits[d9] = false;
                                            }
                                            digits[d8] = false;
                                        }
                                        digits[d7] = false;
                                    }
                                    digits[d6] = false;
                                }
                                digits[d5] = false;
                            }
                            digits[d4] = false;
                        }
                        digits[d3] = false;
                    }
                    digits[d2] = false;
                }
                digits[d1] = false;
            }
            return sum;
        }
        #endregion
        #region Problem 44
        public ulong Problem44() {
            const ulong limit = 10000; // arbitrary limit
            Dictionary<ulong, ulong> pentagonals = new Dictionary<ulong, ulong>();
            for (ulong n = 1; n <= limit; n++)
                pentagonals.Add(Pentagonal(n), n);
            foreach (KeyValuePair<ulong, ulong> kv1 in pentagonals) {
                foreach (KeyValuePair<ulong, ulong> kv2 in pentagonals) {
                    ulong diff = kv2.Key - kv1.Key; // kv2 is always >= kv1
                    ulong sum = kv2.Key + kv1.Key;
                    ulong value;
                    if (pentagonals.TryGetValue(diff, out value) && pentagonals.TryGetValue(sum, out value))
                        return diff;
                }
            }
            return 0;
        }
        #endregion
        #region Problem 45
        public ulong Problem45() {
            const ulong start = 40755;
            // Triangle         T(n) = n(n+1)/2
            // Pentagonal 	  	P(n) = n(3n-1)/2
            // Hexagonal 	  	H(n) = n(2n-1)
            ulong n = (ulong)(1 + Math.Sqrt(8 * start + 1)) / 4; // from Hexagonal  2*n^2 - n - H(n) = 0 --> n = ( 1 + sqrt(8*H(n)+1) ) / 4
            // No need to test Triangle because they are a subset of hexagonal
            ulong result = 0;
            while (true) {
                n++;
                // Compute next hexagonal
                ulong hexagonal = Hexagonal(n);
                // Check if pentagonal  n = ( 1 + sqrt(24*P(n)+1) ) + 6
                if (IsPentagonal(hexagonal)) {
                    result = hexagonal;
                    break;
                }
            }
            return result;
        }
        #endregion
        #region Problem 46
        public ulong Problem46() {
            Dictionary<ulong, ulong> primes = new Dictionary<ulong, ulong>();
            primes.Add(2, 2);
            primes.Add(3, 3);

            ulong result = 0;
            ulong n = 5;
            while (true) {
                bool fPrime = true;
                foreach (KeyValuePair<ulong, ulong> kv in primes)
                    if (0 == (n % kv.Key)) {
                        fPrime = false;
                        break;
                    }
                if (fPrime)
                    primes.Add(n, n);
                else {
                    bool fFound = false;
                    for (ulong i = 1; i * i <= n; i++) {
                        ulong number = n - 2 * i * i;
                        if (primes.ContainsKey(number)) {
                            fFound = true;
                            break;
                        }
                    }
                    if (!fFound) {
                        result = n;
                        break;
                    }
                }
                n += 2; // Only odd composite
            }
            return result;
        }
        #endregion
        #region Problem 47
        public ulong Problem47() {
            const ulong factorCountLimit = 4;
            const ulong consecutiveCountLimit = 4;
            const ulong limit = 500 * 1000;
            const ulong sieveLimit = 1000;
            ulong result = 0;
            ulong count = 0;
            bool fFound = false;
            bool[] sieve = BuildSieve(sieveLimit);
            for (ulong i = 10; i <= limit; i++) {
                ulong n = i;
                ulong factor = 2;
                ulong factorCount = 0;
                while (true) {
                    ulong occurence = 0;
                    while (0 == (n % factor)) { // Count factor occurence
                        occurence++;
                        n /= factor;
                    }
                    if (occurence > 0)
                        factorCount++;
                    if (factorCount > factorCountLimit)
                        break; // No need of more than 4 factors
                    if (n == 1) // No more factoring
                        break;
                    bool fStop = false;
                    while (true) { // Get next prime
                        factor++;
                        if (factor > sieveLimit) {
                            fStop = true;
                            break;
                        }
                        if (!sieve[factor])
                            break;
                    }
                    if (fStop)
                        break;
                }
                if (factorCountLimit == factorCount) {
                    if (0 == count) {
                        result = i;
                        count = 1;
                    }
                    else if (result + 1 == i) {
                        result = i;
                        count++;
                    }
                    if (consecutiveCountLimit == count) {
                        fFound = true;
                        break;
                    }
                }
                else
                    count = 0;
            }
            return fFound ? result - consecutiveCountLimit + 1 : 0;
        }
        #endregion
        #region Problem 48
        public ulong Problem48() {
            // Only the last 10 digits are significant
            const ulong last10digits = 10000000000;
            ulong sum = 0;
            for (ulong i = 1; i <= 1000; i++) {
                ulong pow = PowModulo(i, i, last10digits);
                sum = (sum + pow) % last10digits; // last 10 digits;
            }
            return sum;
        }
        #endregion
        #region Problem 49
        public ulong Problem49() {
            //ulong result = 0;
            //for ( ulong n = 1001; n <= 9999-2*3330; n += 2 ) {
            //    if (n != 1487 && n != 1487 + 3330 && n != 1487+2*3330 && IsPrime(n)) {
            //        ulong n1 = n + 3330;
            //        ulong n2 = n + 2 * 3330;
            //        if (IsPrime(n1) && IsPrime(n2)) {
            //            List<char> strN = new List<char>(n.ToString().ToCharArray());
            //            List<char> strN1 = new List<char>(n1.ToString().ToCharArray());
            //            List<char> strN2 = new List<char>(n2.ToString().ToCharArray());
            //            strN.Sort();
            //            strN1.Sort();
            //            strN2.Sort();
            //            bool fOk = true;
            //            for ( int i = 0; i < strN.Count; i++ )
            //                if (strN[i] != strN1[i] || strN[i] != strN2[i]) {
            //                    fOk = false;
            //                    break;
            //                }
            //            if (fOk) {
            //                result = Convert.ToUInt64(n.ToString() + n1.ToString() + n2.ToString());
            //                break;
            //            }
            //        }
            //    }
            //}
            //return result;

            const ulong limit = 10000;
            ulong result = 0;
            bool[] sieve = BuildSieve(limit);
            bool fStop = false;
            for (ulong n = 1001; n < limit && !fStop; n += 2) {
                if (n == 1487 || n == 4817 || n == 8147)
                    continue;
                if (sieve[n])
                    continue;
                //for (ulong n1 = n + 2; n1 <= 9999 && !fStop; n1 += 2) {
                for (ulong n1 = n + 3330; n1 <= 9999 && !fStop; n1 += 3330) {
                    if (sieve[n1])
                        continue;
                    ulong diff = n1 - n;
                    ulong n2 = n1 + diff;
                    if (n2 > 9999 || sieve[n2])
                        continue;
                    if (IsPermutation(n, n1) && IsPermutation(n, n2)) {
                        result = Convert.ToUInt64(n.ToString() + n1.ToString() + n2.ToString());
                        fStop = true;
                    }
                }
            }
            return result;
        }
        #endregion
        #region Problem 50
        public ulong Problem50() {
            //// Brute-force
            //ulong limit = 1000000;
            //bool[] sieve = BuildSieve(limit);
            //int maxCount = 0;
            //ulong nMax = 0;
            //for (ulong n = 1001; n < limit; n += 2) {
            //    if (sieve[n])
            //        continue;
            //    for (ulong start = 2; start <= 13; start++) {
            //        if (sieve[start])
            //            continue;
            //        ulong sum = start;
            //        int count = 1;
            //        for (ulong p = start + 1; p < n; p++) {
            //            if (sieve[p])
            //                continue;
            //            sum += p;
            //            count++;
            //            if (sum >= n)
            //                break;
            //        }
            //        if (sum == n)
            //            if (count > maxCount) {
            //                maxCount = count;
            //                nMax = n;
            //            }
            //    }
            //}
            //return nMax;

            const ulong limit = 1000000;
            bool[] sieve = BuildSieve(limit);
            ulong maxCount = 0;
            ulong nMax = 0;
            // n(n+1)/2 = sum(i) with sum(i) = 1000000  -> n ~= 1413 (should be lower because prime[i] > i)
            // the gap between 2 primes is > 1 (except for 2 and 3) so we can divide 1413 by 2
            // we suppose there is at least 200 terms
            for (ulong i = 200; i <= 707; i++) {
                for (ulong start = 2; start <= 13; start++) { // a long chain must start with the first primes
                    if (sieve[start])
                        continue;
                    ulong sum = (ulong)start;
                    ulong count = 1;
                    ulong p = start + 1;
                    while (true) {
                        if (!sieve[p]) {
                            sum += (ulong)p;
                            count++;
                            if (sum >= limit)
                                break;
                            if (count == i)
                                break;
                        }
                        p++;
                    }
                    if (count == i && sum <= limit && !sieve[sum])
                        if (count > maxCount) {
                            maxCount = count;
                            nMax = sum;
                        }
                }
            }
            return nMax;
        }
        #endregion
        #region Problem 51
        public ulong Problem51() {
            // last digit doesnt count because we can't replace it by 0, 2, 5, 4, 6, 8
            const ulong limit = 1000000;
            bool[] sieve = BuildSieve(limit);
            int[] digits = new int[10];
            for (ulong n = 10001; n < limit; n += 2) {
                if (sieve[n]) continue;
                // Check if the number has more than 2 repeating digits excluding last digit
                // Count digits
                string s = n.ToString();
                for (int i = 0; i < 10; i++) digits[i] = 0;
                for (int i = 0; i < s.Length - 1; i++)
                    digits[ToInt32(s[i])]++;
                // 2 digits
                for (int i = 0; i < digits.Length; i++) {
                    if (digits[i] >= 2) {
                        int count = 0;
                        for (int j = 0; j <= 9; j++) {
                            string t = s.Replace((char)(i + 48), (char)(j + 48));
                            int n2 = Convert.ToInt32(t);
                            if (!sieve[n2] && n2.ToString().Length == s.Length) // prime and no leading 0
                                count++;
                        }
                        if (count == 8)
                            return (ulong)n;
                    }
                }
            }
            return 0;
        }
        #endregion
        #region Problem 52
        //private string _52_SortString(string s) {
        //    char[] arr = s.ToCharArray();
        //    Array.Sort(arr);
        //    return new string(arr);
        //}
        private ulong _52_Hash(ulong n) {
            ulong r = 1;
            while (n > 0) {
                r *= Primes10[n % 10];
                n /= 10;
            }
            return r;
        }
        public ulong Problem52() {
            ulong n = 1;
            ulong result = 0;
            while (true) {
                //string sortedString = _52_SortString(n.ToString());
                //if (
                //    sortedString == _52_SortString((n * 2).ToString())
                //    && sortedString == _52_SortString((n * 3).ToString())
                //    && sortedString == _52_SortString((n * 4).ToString())
                //    && sortedString == _52_SortString((n * 5).ToString())
                //    && sortedString == _52_SortString((n * 6).ToString())
                //    ) {
                //    result = n;
                //    break;
                //}
                ulong hash = _52_Hash(n);
                if (
                    hash == _52_Hash(n * 2)
                    && hash == _52_Hash(n * 3)
                    && hash == _52_Hash(n * 4)
                    && hash == _52_Hash(n * 5)
                    && hash == _52_Hash(n * 6)
                    ) {
                    result = n;
                    break;
                }

                n++;
            }
            return result;
        }
        #endregion
        #region Problem 53
        private double _53_Cnk(int n, int k) {
            // n!/(k!(n-k)!)
            double result = 1;
            for (int i = k + 1; i <= n; i++)
                result *= (double)i;
            for (int i = 1; i <= (n - k); i++)
                result /= (double)i;
            return result;
        }
        public ulong Problem53() {
            const ulong limit = 1000000;
            // C(n,k) == C(n,n-k)
            const int nLimit = 100;
            ulong count = 0;
            for (int n = 23; n <= nLimit; n++)
                for (int k = 1; k < n; k++) {
                    double Cnr = _53_Cnk(n, k);
                    if (Cnr >= limit) { // Once the limit is reached, every number between k and n-k will break the limit
                        count += (ulong)(n + 1 - 2 * k);
                        break;
                    }
                }
            return count;
        }
        #endregion
        #region Problem 55
        private string _55_ReverseString(string s) {
            StringBuilder result = new StringBuilder(s.Length);
            int len = s.Length - 1;
            for (int i = 0; i <= len; i++)
                result.Append(s[len - i]);
            return result.ToString();
        }
        private bool _55_IsPalindromic(string s) {
            for (int i = 0; i < s.Length / 2; i++)
                if (s[i] != s[s.Length - i - 1])
                    return false;
            return true;
        }
        public ulong Problem55() {
            const ulong limit = 10000;
            ulong count = 0;
            for (ulong i = 11; i <= limit; i++) {
                bool fOk = false;
                string n = i.ToString();
                for (int t = 0; t < 50; t++) {
                    string reverse = _55_ReverseString(n);
                    string sum = SumString(n, reverse);
                    if (_55_IsPalindromic(sum)) {
                        fOk = true;
                        break;
                    }
                    n = sum;
                }
                if (!fOk)
                    count++;
            }
            return count;
        }
        #endregion
        #region Problem 56
        public ulong Problem56() {
            //ulong bestDigitSum = 0;
            //for ( uint i = 90; i <= 99; i++ ) {
            //    for (uint j = 90; j <= 99; j++) {
            //        BigInt power = BigInt.Power(i, j);
            //        ulong sum = SumDigits(power.ToString());
            //        if (sum > bestDigitSum)
            //            bestDigitSum = sum;
            //    }
            //return bestDigitSum;

            // biggest number = 99^99
            // number of digits = floor(99*log10(99))+1
            const ulong limit = 99;
            ulong limitDigitsCount = (ulong)((double)limit * Math.Log10(limit)) + 1;
            ulong[] digits = new ulong[limitDigitsCount];
            ulong bestDigitSum = 0;
            ulong bestBase = 0;
            ulong bestExponent = 0;
            for (uint b = 90; b <= limit; b++) { // 90->99
                for (int i = 0; i < digits.Length; i++) digits[i] = 0;
                digits[0] = 1; // starts with 1
                ulong digitCount = 1;
                for (ulong e = 1; e <= limit; e++) { // compute each power of base
                    MulDigitsNumber(digits, ref digitCount, b);
                    ulong sum = 0;
                    foreach (ulong digit in digits)
                        sum += digit;
                    if (sum > bestDigitSum) {
                        bestBase = b;
                        bestExponent = e;
                        bestDigitSum = sum;
                    }
                }
            }
            return bestDigitSum;
        }
        #endregion
        #region Problem 57
        public ulong Problem57() {
            // sqrt(2) = 1 + 1/(2+1/(2+1/(2+...)))
            // 1 + 1/2
            // 1 + 1/(2+1/2)
            // 1 + 1/(2+1/(2+1/2))
            // 1 + 1/(2+1/(2+1/(2+1/2)))
            // a(0) = 0
            // a(1) = 1+1/(2+a(0))            N(1)/D(1) = 3/2
            // a(2) = 1+1/(2+a(1))            N(2)/D(2) = (2*D(1)+N(1)) / (D(1)+N(1))
            // a(n) = 1+1/(2+a(n-1))          N(n)/D(n) = (2*D(n-1)+N(n-1)) / (D(n-1)+N(n-1))
            ulong count = 0;
            string previousNumerator = "1";
            string previousDenominator = "1";
            for (int i = 1; i <= 1000; i++) {
                string denominator = SumString(previousNumerator, previousDenominator);
                string numerator = SumString(denominator, previousDenominator);
                previousNumerator = numerator;
                previousDenominator = denominator;
                if (numerator.Length > denominator.Length)
                    count++;
            }
            return count;
        }
        #endregion
        #region Problem 58
        public ulong Problem58() {
            // Corners: n^2-3n+3, n^2-2n+2, n^2-n+1, n^2
            // diagonal count = 2*(n-1)+1 with n odd
            ulong n = 3;
            ulong primeCount = 0;
            while (true) {
                ulong c0 = n * n - 3 * n + 3;
                ulong c1 = n * n - 2 * n + 2;
                ulong c2 = n * n - n + 1;
                //ulong c3 = n * n; // never a prime
                if (IsPrime(c0))
                    primeCount++;
                if (IsPrime(c1))
                    primeCount++;
                if (IsPrime(c2))
                    primeCount++;
                ulong count = 2 * (n - 1) + 1;
                if (10 * primeCount <= count)
                    break;
                n += 2;
            }
            return n;
        }
        #endregion
        #region Problem 59
        public ulong Problem59() {
            using (System.IO.StreamReader reader = new System.IO.StreamReader(@"..\..\..\cipher1.txt")) {
                string fileContent = reader.ReadToEnd();
                string[] numbers = fileContent.Split(',');
                char[] encrypted = new char[numbers.Length];
                for (int i = 0; i < numbers.Length; i++)
                    encrypted[i] = (char)(Convert.ToInt32(numbers[i]));
                char[] key = new char[3];
                char[] bestDecoded = null;
                int bestCount = 0;
                bool fStop = false;
                for (char k1 = 'a'; k1 <= 'z' && !fStop; k1++) {
                    key[0] = k1;
                    for (char k2 = 'a'; k2 <= 'z' && !fStop; k2++) {
                        key[1] = k2;
                        for (char k3 = 'a'; k3 <= 'z' && !fStop; k3++) {
                            char[] decoded = new char[encrypted.Length];
                            key[2] = k3;
                            for (int i = 0; i < encrypted.Length; i++)
                                decoded[i] = (char)(encrypted[i] ^ key[i % 3]);
                            string s = new string(decoded);
                            // Method 1: Look for " the "
                            //if (s.Contains(" the ")) {
                            //  bestDecoded = decoded;
                            //  fStop = true;
                            //}
                            // Method 2: Frequencies count
                            int count = 0;
                            string sToLower = s.ToLower();
                            foreach (char c in sToLower)
                                if (c == 'e' || c == 'a' || c == 't' || c == 'i' || c == 'n' || c == ' ')
                                    count++;
                            if (count > bestCount) {
                                bestDecoded = decoded;
                                bestCount = count;
                            }
                        }
                    }
                }
                if (null != bestDecoded) {
                    ulong sum = 0;
                    foreach (char c in bestDecoded)
                        sum += c;
                    return sum;
                }
                return 0;
            }
        }
        #endregion
        #region Problem 60
        public ulong Problem60() {
            // Brute-force
            const ulong sieveLimit = 100000000;
            bool[] sieve = BuildSieve(sieveLimit); // slowest step
            ulong[] limits = { 9999, 9999, 9999, 9999, 9999 }; // arbitrary limit
            ulong sum = 0;
            ulong concat, index;
            bool fContinue = true;
            ulong[] p = new ulong[5];
            for (p[0] = 3; p[0] <= limits[0]; p[0] += 2) { // 2 will never be concatenable to give another prime
                if (sieve[p[0]])
                    continue;
                for (p[1] = p[0] + 2; p[1] <= limits[1]; p[1] += 2) {
                    if (sieve[p[1]])
                        continue;
                    index = 1;
                    fContinue = false;
                    for (ulong i = 0; i < index; i++) {
                        concat = Convert.ToUInt64(p[index].ToString() + p[i].ToString());
                        if (sieve[concat]) {
                            fContinue = true;
                            break;
                        }
                        concat = Convert.ToUInt64(p[i].ToString() + p[index].ToString());
                        if (sieve[concat]) {
                            fContinue = true;
                            break;
                        }
                    }
                    if (fContinue)
                        continue;
                    for (p[2] = p[1] + 2; p[2] <= limits[2]; p[2] += 2) {
                        if (sieve[p[2]])
                            continue;
                        index = 2;
                        fContinue = false;
                        for (ulong i = 0; i < index; i++) {
                            concat = Convert.ToUInt64(p[index].ToString() + p[i].ToString());
                            if (sieve[concat]) {
                                fContinue = true;
                                break;
                            }
                            concat = Convert.ToUInt64(p[i].ToString() + p[index].ToString());
                            if (sieve[concat]) {
                                fContinue = true;
                                break;
                            }

                        }
                        if (fContinue)
                            continue;
                        for (p[3] = p[2] + 2; p[3] <= limits[3]; p[3] += 2) {
                            if (sieve[p[3]])
                                continue;
                            index = 3;
                            fContinue = false;
                            for (ulong i = 0; i < index; i++) {
                                concat = Convert.ToUInt64(p[index].ToString() + p[i].ToString());
                                if (sieve[concat]) {
                                    fContinue = true;
                                    break;
                                }
                                concat = Convert.ToUInt64(p[i].ToString() + p[index].ToString());
                                if (sieve[concat]) {
                                    fContinue = true;
                                    break;
                                }

                            }
                            if (fContinue)
                                continue;
                            for (p[4] = p[3] + 2; p[4] <= limits[4]; p[4] += 2) {
                                if (sieve[p[4]])
                                    continue;
                                index = 4;
                                fContinue = false;
                                for (ulong i = 0; i < index; i++) {
                                    concat = Convert.ToUInt64(p[index].ToString() + p[i].ToString());
                                    if (sieve[concat]) {
                                        fContinue = true;
                                        break;
                                    }
                                    concat = Convert.ToUInt64(p[i].ToString() + p[index].ToString());
                                    if (sieve[concat]) {
                                        fContinue = true;
                                        break;
                                    }

                                }
                                if (fContinue)
                                    continue;
                                // We have found the 5 numbers
                                sum = 0;
                                for (int i = 0; i < 5; i++)
                                    sum += p[i];
                                return sum;
                            }
                        }
                    }
                }
            }
            return 0;
        }
        #endregion
        #region Problem 61
        private delegate double _61_GetIndex(ulong number);
        private delegate ulong _61_GetPolygonal(ulong n);
        private List<ulong> _61_BuildPolygonalList(ulong lowerBound, ulong upperBound, _61_GetIndex GetIndex, _61_GetPolygonal GetPolygonal) {
            List<ulong> list = new List<ulong>();
            ulong lowerLimit = (ulong)GetIndex(lowerBound);
            ulong upperLimit = (ulong)Math.Ceiling(GetIndex(upperBound));
            for (ulong i = lowerLimit; i <= upperLimit; i++) {
                ulong number = GetPolygonal(i);
                if (number > upperBound)
                    break;
                if (number >= lowerBound)
                    list.Add(number);
            }

            return list;
        }
        private bool _61_Sub(ulong number, List<List<ulong>> collectionsLeft, ulong startItem/*, ulong depth*/, ref ulong[] items) {
            bool fStop = false;
            foreach (List<ulong> collection in collectionsLeft) {
                foreach (ulong polygonal in collection) {
                    if ((number % 100) == (polygonal / 100)) { // 2 last matches 2 first
                        items[items.Length - collectionsLeft.Count] = polygonal;
                        //Console.WriteLine("".PadLeft((int)(depth*3)) + " " + number+"-->"+polygonal+"["+collection.Count+"]");
                        if (collectionsLeft.Count == 1 && (polygonal % 100) == (startItem / 100)) {  // 2 last matches 2 first
                            fStop = true;
                            break;
                        }
                        List<List<ulong>> left = new List<List<ulong>>();
                        foreach (List<ulong> c in collectionsLeft)
                            if (c != collection)
                                left.Add(c);
                        fStop = _61_Sub(polygonal, left, startItem/*, depth + 1*/, ref items);
                        if (fStop)
                            break;
                    }
                }
                if (fStop)
                    break;
            }
            return fStop;
        }
        public ulong Problem61() {
            const ulong lowerBound = 1000; // 4 digits
            const ulong upperBound = 9999; // 4 digits

            List<ulong> triangles = _61_BuildPolygonalList(lowerBound, upperBound, TriangleIndex, Triangle);
            List<ulong> squares = _61_BuildPolygonalList(lowerBound, upperBound, SquareIndex, Square);
            List<ulong> pentagonals = _61_BuildPolygonalList(lowerBound, upperBound, PentagonalIndex, Pentagonal);
            List<ulong> hexagonals = _61_BuildPolygonalList(lowerBound, upperBound, HexagonalIndex, Hexagonal);
            List<ulong> heptagonals = _61_BuildPolygonalList(lowerBound, upperBound, HeptagonalIndex, Heptagonal);
            List<ulong> octogonals = _61_BuildPolygonalList(lowerBound, upperBound, OctogonalIndex, Octogonal);

            // abcd -> cdef -> efgh -> ghij -> ijkl -> klab
            // loop among octogonals ==> abcd
            // search in other collections for cdef
            // search in other collections for efgh
            // search in other collections for ghij
            // search in other collections for ijkl
            // search in last collection for klab
            ulong sum = 0;
            foreach (ulong octogonal in octogonals) {
                //Console.WriteLine("======");
                List<List<ulong>> collectionsLeft = new List<List<ulong>>(new List<ulong>[] { heptagonals, hexagonals, pentagonals, squares, triangles });
                ulong[] items = new ulong[collectionsLeft.Count + 1];
                items[0] = octogonal;
                bool fFound = _61_Sub(octogonal, collectionsLeft, octogonal/*, 1*/, ref items);
                if (fFound) {
                    foreach (ulong item in items) {
                        //Console.Write(item + "->");
                        sum += item;
                    }
                    break;
                }
            }
            return sum;
        }
        #endregion
        #region Problem 62
        public ulong Problem62() {
            const ulong limit = 1000000;
            // key: cube sorted digits
            // value: list of number whose cube sorted digits equals key
            Dictionary<string, List<ulong>> dict = new Dictionary<string, List<ulong>>();
            for (ulong i = 1; i < limit; i++) {
                // compute cube
                ulong cube = i * i * i;
                // sort digits
                char[] arr = cube.ToString().ToCharArray();
                Array.Sort(arr);
                string sorted = new string(arr);
                // search in dictionary if cube already exists
                List<ulong> list;
                bool fFound = dict.TryGetValue(sorted, out list);
                if (!fFound) {
                    list = new List<ulong>();
                    dict.Add(sorted, list);
                }
                list.Add(i);
                if (5 == list.Count) { // maybe we could have 6 permutations?
                    ulong min = list[0];
                    for (int j = 1; j < list.Count; j++)
                        if (list[j] < min)
                            min = list[j];
                    return min * min * min;
                }
            }
            return 0;
        }
        #endregion
        #region Problem 63
        private string _63_MulStringByDigit(string multiplicand, int multiplier) {
            StringBuilder result = new StringBuilder(multiplicand.Length + 1);
            int carry = 0;
            for (int i = multiplicand.Length - 1; i >= 0; i--) {
                int digitA = ToInt32(multiplicand[i]);
                int product = digitA * multiplier + carry;
                carry = product / 10;
                int digit = product % 10;
                result.Insert(0, digit);
            }
            if (carry > 0)
                result.Insert(0, carry);
            return result.ToString();
        }
        public ulong Problem63() {
            // 10^n has n+1 digits
            // n must be <= 9 if we want only n digits
            //
            // length(a^b)=n
            // floor(log10(a^b))+1 = b
            // log10(a^b) < b-1
            // b*log10(a) < b-1
            // log10(a) < (b-1)/b
            // b < 1/(1-log10(a))
            // limit a = 9 -> b < 22
            //
            // 9^22 > 64bits!!!
            ulong count = 0;
            for (int a = 1; a < 10; a++) {
                string s = "1";
                for (int b = 1; b <= 22; b++) {
                    s = _63_MulStringByDigit(s, a);
                    if (s.Length == b)
                        count++;
                }
            }
            return count;
        }
        #endregion
        #region Problem 64
        public ulong Problem64() {
            const ulong limit = 10000;
            ulong count = 0;
            for (ulong n = 2; n <= limit; n++) {
                ulong sqrtN = (ulong)Math.Sqrt(n);
                if (sqrtN * sqrtN == n)
                    continue;
                List<ulong> continuedFraction = SqrtContinuedFraction(n);
                if (0 == (continuedFraction.Count & 1)) // odd period <- even list item count
                    count++;
            }
            return count;
        }
        #endregion
        #region Problem 65
        public ulong Problem65() {
            //http://en.wikipedia.org/wiki/Continued_fraction#Infinite_continued_fractions
            // e=[2;1,2,1,1,4,1,16,1,1,...,2n,1,1,...]
            // No need to compute the denominator
            // 100th convergent > 64bits
            const ulong limit = 100;
            string numerator_2 = "1264";
            string numerator_1 = "1457";
            string numerator = "";
            for (ulong i = 11; i <= limit; i++) {
                ulong continuedFraction = (0 == (i % 3)) ? 2 * (i / 3) : 1;
                //numerator = numerator_2 + numerator_1 * continuedFraction;
                numerator = numerator_2;
                for (ulong j = 0; j < continuedFraction; j++) // compute numerator_1 * continuedFraction
                    numerator = SumString(numerator, numerator_1);
                numerator_2 = numerator_1;
                numerator_1 = numerator;
            }
            return SumDigits(numerator);
        }
        #endregion
        #region Problem 66
        public string Problem66() {
            //http://en.wikipedia.org/wiki/Pell%27s_equation#Fundamental_solution_via_continued_fractions
            // X^2 - D*Y^2 = 1
            const ulong limit = 1000;
            BigInt max = 0;
            ulong maxN = 0;
            for (ulong n = 2; n <= limit; n++) {
                ulong sqrtN = (ulong)Math.Sqrt(n);
                if (sqrtN * sqrtN == n)
                    continue; // No solution if D is a square
                // Continued fraction convergent may be injected as X and Y for diophante equation X^2 - DY^2 until result = 1 (X = numerator and Y = denominator)
                List<ulong> continuedFractions = SqrtContinuedFraction(n);
                BigInt numerator_2 = 1;
                BigInt denominator_2 = 0;
                BigInt numerator_1 = (long)continuedFractions[0];
                BigInt denominator_1 = 1;
                BigInt numerator = 0;
                BigInt denominator = 0;
                BigInt continuedFraction = 0;
                BigInt bigIntN = (long)n;
                int i = 1;
                while (true) {
                    continuedFraction = (long)continuedFractions[i];
                    numerator = numerator_2 + numerator_1 * continuedFraction;
                    denominator = denominator_2 + denominator_1 * continuedFraction;
                    BigInt result = numerator * numerator - bigIntN * denominator * denominator;
                    if (result == 1)
                        break;
                    numerator_2 = numerator_1;
                    numerator_1 = numerator;
                    denominator_2 = denominator_1;
                    denominator_1 = denominator;
                    if (i >= continuedFractions.Count - 1)
                        i = 1;
                    else
                        i++;
                }
                if (numerator > max) {
                    maxN = n;
                    max = numerator;
                }
            }
            return maxN.ToString();
        }
        #endregion
        #region Problem 67
        public ulong Problem67() {
            using (System.IO.StreamReader reader = new System.IO.StreamReader(@"..\..\..\triangle.txt")) {
                List<List<ulong>> triangle = new List<List<ulong>>();
                while (!reader.EndOfStream) {
                    string s = reader.ReadLine();
                    string[] numbers = s.Split(' ');
                    List<ulong> list = new List<ulong>();
                    foreach (string number in numbers)
                        list.Add(Convert.ToUInt64(number));
                    triangle.Add(list);
                }

                // Bottom-up approach, each number n at index i in line l is replaced by max( n+nl[i], n+nl[i+1] ) with nl = next line
                for (int l = triangle.Count - 2; l >= 0; l--) {
                    List<ulong> nextLine = triangle[l + 1];
                    List<ulong> line = triangle[l];
                    for (int i = 0; i < line.Count; i++) {
                        ulong sum1 = line[i] + nextLine[i];
                        ulong sum2 = line[i] + nextLine[i + 1];
                        line[i] = Math.Max(sum1, sum2);//sum1 > sum2 ? sum1 : sum2;
                    }
                }
                return triangle[0][0];
            }
        }
        #endregion
        #region Problem 68
        public string Problem68() {
            // end of line a, b, c, d, e
            // pentagon f, g, h, i, j
            // a-f-g
            // b-g-h
            // c-h-i
            // d-i-j
            // e-j-f
            // 10 must be in the outer ring to give 16-digit
            // the highest values must be in the outer ring
            // a must be equal to 6, sequence must start with the lowest external node
            // fix a, b, c, d, e to 6, 10, 9, 8, 7
            const int limit = 5;
            const int a = 6;
            const int b = 10;
            const int c = 9;
            const int d = 8;
            const int e = 7;
            List<string> solutions = new List<string>();
            bool[] used = new bool[limit];
            string max = "0";
            for (int f = 1; f <= limit; f++) {
                used[f - 1] = true;
                for (int g = 1; g <= limit; g++) {
                    if (used[g - 1]) continue;
                    used[g - 1] = true;
                    for (int h = 1; h <= limit; h++) {
                        if (used[h - 1]) continue;
                        used[h - 1] = true;
                        for (int i = 1; i <= limit; i++) {
                            if (used[i - 1]) continue;
                            used[i - 1] = true;
                            int j = 0;
                            for (int t = 0; t < limit; t++)
                                if (!used[t]) {
                                    j = t + 1;
                                    break;
                                }
                            int sum1 = a + f + g;
                            int sum2 = b + g + h;
                            int sum3 = c + h + i;
                            int sum4 = d + i + j;
                            int sum5 = e + j + f;
                            if (sum1 == sum2 && sum1 == sum3 && sum1 == sum4 && sum1 == sum5) {
                                string s =
                                    a.ToString() + f.ToString() + g.ToString()
                                    + b.ToString() + g.ToString() + h.ToString()
                                    + c.ToString() + h.ToString() + i.ToString()
                                    + d.ToString() + i.ToString() + j.ToString()
                                    + e.ToString() + j.ToString() + f.ToString();
                                solutions.Add(s);
                                if (string.Compare(s, max) > 0)
                                    max = s;
                            }
                            used[i - 1] = false;
                        }
                        used[h - 1] = false;
                    }
                    used[g - 1] = false;
                }
                used[f - 1] = false;
            }
            return max;
        }
        #endregion
        #region Problem 69
        //private ulong _69_GetFactorsCount(bool[] sieve, ulong n) {
        //    ulong sqrtN = (ulong)Math.Sqrt(n);
        //    ulong factorsCount = 0;
        //    for (ulong j = 2; j <= sqrtN; j++)
        //        if (!sieve[j] && (0 == (n % j)))
        //            factorsCount += 2;
        //    if (sqrtN * sqrtN == n)
        //        factorsCount--; // sqrtN is counted twice if N is a perfect square
        //    return factorsCount;
        //}
        public ulong Problem69() {
            //// Brute-force
            //// maximize n/phi(n) is equivalent to maximize the number of factors
            //// phi(n) will be low if the number of factors is high because the numbers relatively prime to n will be low
            //ulong limit = 1000000;
            //bool[] sieve = BuildSieve(1001); // sqrt limit
            //ulong maxN = 0;
            //ulong maxFactor = 0;
            //for (ulong n = 3; n < limit; n++) {
            //    ulong factorsCount = _69_GetFactorsCount(sieve, n);
            //    if (factorsCount > maxFactor) {
            //        //Console.WriteLine("n:" + n + "->" + factorsCount);
            //        maxFactor = factorsCount;
            //        maxN = n;
            //    }
            //}
            //return maxN;

            // max is the product of the n first primes
            const ulong limit = 1000000;
            ulong sqrtLimit = (ulong)(Math.Sqrt(limit) + 0.5);
            ulong product = 2;
            for (ulong n = 3; n <= sqrtLimit; n += 2)
                if (IsPrime(n)) {
                    ulong newProduct = product * n;
                    if (newProduct > limit)
                        break;
                    else
                        product = newProduct;
                }
            return product;
        }
        #endregion
        #region Problem 70
        public ulong Problem70() {
            //// Brute-force too slow
            //ulong limit = 10000000;
            //bool[] sieve = BuildSieve(limit);
            //double minRatio = 9999999999;
            //ulong minN = 0;
            //for (ulong n = 4; n < limit; n++) {
            //    if (sieve[n]) { // no need to test prime number
            //        ulong phiN = Phi(sieve, n);
            //        if (IsPermutation(n, phiN)) {
            //            double ratio = (double)n / (double)phiN;
            //            //if (ratio < minRatio) {
            //            Console.WriteLine("n" + n + "->" + phiN + "|" + ratio);
            //            minRatio = ratio;
            //            minN = n;
            //            //}
            //        }
            //    }
            //}
            //return minN;

            // phi(prime) = prime-1   ==> prime and prime-1 cannot be a permutation of each other
            // to minimize n/phi(n) we have to maximize phi(n)
            // phi(n) = n * (1-1/p1) * (1-1/p2) ... * (1-1/pk) where pk are prime factor of n
            // phi(n) decreases with the number of prime factor
            // we have to minimize the number of factor to maximize phi(n)
            // primes are rejected, so n must be the product of 2 primes
            // n = p1*p2
            // phi(n) = n * (1-1/p1) * (1-1/p2) = n * (p1-1)/p1 * (p2-1)/p2 = (p1-1)*(p2-1)
            const ulong limit = 10000000;
            bool[] sieve = BuildSieve(10000); // 2.5*sqrt(limit) to be sure
            double minRatio = double.MaxValue;
            ulong minN = 0;
            for (ulong p1 = 3; p1 < (ulong)sieve.Length; p1 += 2) {
                if (sieve[p1]) continue;
                for (ulong p2 = p1 + 2; p2 < (ulong)sieve.Length; p2 += 2) {
                    if (sieve[p2]) continue;
                    ulong n = p1 * p2;
                    if (n < limit) {
                        ulong phiN = (p1 - 1) * (p2 - 1);
                        if (IsPermutation(n, phiN)) {
                            double ratio = (double)n / (double)phiN;
                            if (ratio < minRatio) {
                                //Console.WriteLine("n:" + n + "->" + phiN + "|" + ratio + "|" + p1 + "*" + p2);
                                minRatio = ratio;
                                minN = n;
                            }
                        }
                    }
                }
            }
            return minN;
        }
        #endregion
        #region Problem 71
        public ulong Problem71() {
            // must find the largest n  with n/d < a/b, d <= 1000000, a=3 and b=7
            // n/d < a/b ==> nb < ad ==> nb <= ad-1 ==> n <= floor(ad-1/b)
            // n/d will be the largest fraction < a/b if n = floor(ad-1/b)
            const ulong limit = 1000000;
            const ulong a = 3;
            const ulong b = 7;
            ulong bestN = 0;
            ulong bestD = 1;
            for (ulong d = 2; d <= limit; d++) {
                ulong n = (a * d - 1) / b;
                ulong pgcd = PGCD(n, d);
                if (1 == pgcd && n * bestD > bestN * d) {// n/d > bestN/bestD
                    bestN = n;
                    bestD = d;
                }
            }
            return bestN;
        }
        #endregion
        #region Problem 72
        public ulong Problem72() {
            // 1: /
            // 2: 1/2
            // 3: 1/3 2/3
            // 4: 1/4 3/4
            // 5: 1/5 2/5 3/5 4/5
            // 6: 1/6 5/6
            // 7: 1/7 2/7 3/7 4/7 5/7 6/7
            // 8: 1/8 3/8 5/8 7/8
            // 9: 1/9 2/9 4/9 5/9 7/9 8/9
            // number of reduced fraction with denominator d = phi(d)


            //// Brute-force too slow
            //ulong limit = 1000000;
            //bool[] sieve = BuildSieve(limit);
            //ulong sum = 0;
            //for (ulong d = 2; d <= limit; d++)
            //    sum += Phi(sieve,d);
            //return sum;

            // Initialize phi(n) with n
            // each time we find a prime, for each multiple of this prime we'll multiply phi(prime*multiple) by (1-1/prime)
            const ulong limit = 1000000;
            bool[] sieve = new bool[limit + 1];
            for (int i = 0; i < sieve.Length; i++)
                sieve[i] = true;
            ulong[] phi = new ulong[limit + 1];
            for (int i = 0; i < phi.Length; i++)
                phi[i] = (ulong)i;
            // some values are hard-coded
            sieve[0] = false;
            sieve[1] = false;
            // Phi sieve
            for (ulong n = 2; n <= limit; n++)
                if (sieve[n]) {
                    phi[n] = n - 1; // phi of a prime is prime-1
                    for (ulong multiple = 2; n * multiple <= limit; multiple++) {
                        sieve[n * multiple] = false;
                        phi[n * multiple] = (phi[n * multiple] * (n - 1)) / n; // a*(1-1/p) = a*(p-1)/p
                    }
                }
            ulong sum = 0;
            foreach (ulong p in phi)
                sum += p;
            return sum - 1; // -1 because 1 doesn't give a reduced fraction
        }
        #endregion
        #region Problem 73
        public ulong Problem73() {
            // must find the largest n
            //  with n/d < a/b      d <= 12000, a=1 and b=2
            //  and  e/f < n/d      d <= 12000, e=1 and f=3
            // see problem 71
            // lower bound: floor(ed+1/f) 
            // upper bound: floor(ad-1/b)
            const ulong limit = 12000;
            const ulong a = 1;
            const ulong b = 2;
            const ulong e = 1;
            const ulong f = 3;
            ulong count = 0;
            ulong invalid0 = 0; // Debug purpose
            ulong invalid1 = 0;
            ulong invalid2 = 0; // Debug purpose
            for (ulong d = 2; d <= limit; d++) {
                ulong lowerBound = (e * d + 1) / f;
                ulong upperBound = (a * d - 1) / b;
                for (ulong n = lowerBound; n <= upperBound; n++) {
                    if (n * b < a * d && e * d < n * f) {
                        ulong pgcd = PGCD(n, d);
                        if (1 == pgcd)
                            count++;
                        else
                            invalid0++; // Debug purpose
                    }
                    else {
                        if (n * b >= a * d) invalid1++; // Debug purpose
                        if (e * d >= n * f) invalid2++; // Debug purpose
                    }
                }
            }
            return count;
        }
        #endregion
        #region Problem 74
        public ulong Problem74() {
            const ulong limit = 1000000;
            const int chainCount = 60;
            ulong count = 0;
            Dictionary<ulong, int> cache = new Dictionary<ulong, int>();
            for (ulong n = 69; n <= limit; n++) {
                int index = 0;
                bool fFound = false;
                List<ulong> list = new List<ulong>();
                ulong sum = n;
                while (true) {
                    fFound = cache.TryGetValue(sum, out index);
                    if (fFound)
                        break;
                    list.Add(sum);
                    sum = SumFactorialDigits(sum);
                    index = list.IndexOf(sum);
                    if (-1 != index)
                        break;
                }
                // If found, index represents the length of the chain to add
                // Else, index represents the index of the cycle
                for (int i = 0; i < list.Count; i++)
                    if (fFound)
                        cache.Add(list[i], list.Count - i + index);
                    else if (i < index)
                        cache.Add(list[i], list.Count - i); // before cycle, length is equal to length from the beginning
                    else
                        cache.Add(list[i], list.Count - index); // after cycle, length is equal to cycle length
            }
            foreach (KeyValuePair<ulong, int> kv in cache)
                if (kv.Value == chainCount)
                    count++;
            return count;
        }
        #endregion
        #region Problem 75
        public ulong Problem75() {
            // Pythagorean triple n2 – m2, 2mn, n2 + m2  with m > 1 and 1 <= n
            const ulong limit = 1500000;
            ulong sideLimit = (ulong)Math.Sqrt(limit);
            Dictionary<ulong, int> dict = new Dictionary<ulong, int>();
            for (ulong i = 1; i <= sideLimit; i += 2)
                for (ulong j = 2; j <= sideLimit; j += 2) {
                    ulong pgcd = PGCD(i, j);
                    if (1 == pgcd) { // reduced triplet
                        //ulong a = (ulong)Math.Abs((long)(i * i) - (long)(j * j));
                        //ulong b = 2 * i * j;
                        //ulong c = i * i + j * j;
                        //ulong perimeter = a + b + c;
                        ulong perimeter = (i > j) ? (2 * i * i + 2 * i * j) : (2 * j * j + 2 * i * j);
                        for (ulong s = perimeter; s <= limit; s += perimeter) // every multiple of perimeter will be produced by this triplet
                            if (dict.ContainsKey(s))
                                dict[s]++;
                            else
                                dict.Add(s, 1);
                    }
                }
            ulong count = 0;
            foreach (KeyValuePair<ulong, int> kv in dict)
                if (kv.Value == 1)
                    count++;
            return count;
        }
        #endregion
        #region Problem 76
        public ulong Problem76() {
            //http://www.math.temple.edu/~melkamu/html/partition.pdf
            // Euler's formula:
            // P(n) = sum{k=1}^{n}(-1)^{k+1}[P(n-frac(k(3k-1)))+P(n-frac(k(3k+1)))]
            // P(0) = 1
            const long limit = 100;
            long[] p = new long[limit + 1];
            p[0] = 1;
            for (long i = 1; i <= limit; i++) {
                //long sign = +1;
                //p[i] = 0;
                //for (long k = 1; k <= limit; k++) {
                //    long f;
                //    f = k * (3 * k - 1) / 2; // pentagonal(k)
                //    if (f > i)
                //        break;
                //    p[i] += sign * p[i - f];
                //    f = k * (3 * k + 1) / 2;
                //    if (f > i)
                //        break;
                //    p[i] += sign * p[i - f];
                //    sign = -sign;
                //}
                long sum = 0;
                for (long k = 1; k <= i; k++) {
                    long mul = ((k & 1) == 0) ? (-1) : (1);
                    long pos_1 = i - ((3 * k * k - k) / 2); // pentagonal(k)
                    long pos_2 = i - ((3 * k * k + k) / 2); // pentagonal(k)
                    if (pos_1 < 0) break;
                    sum += (pos_1 >= 0) ? (mul * p[pos_1]) : (0);
                    sum += (pos_2 >= 0) ? (mul * p[pos_2]) : (0);
                }
                p[i] = sum;
            }
            return (ulong)(p[100] - 1); // -1 because we want at least two integers

            //ulong target = 100;
            //ulong[] ways = new ulong[target + 1];
            //for (ulong i = 0; i < target + 1; i++) ways[i] = 0;
            //ways[0] = 1;
            //for (ulong n = 1; n < 100; n++)
            //    for (ulong i = n; i < target + 1; i++)
            //        ways[i] += ways[i - n];
            //return ways[target];
        }
        #endregion
        #region Problem 77
        public ulong Problem77() {
            ulong[] primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79 };
            const ulong limit = 5000;
            ulong target = 10;
            while (true) {
                ulong[] ways = new ulong[target + 1];
                for (ulong i = 0; i < target + 1; i++) ways[i] = 0;
                ways[0] = 1;
                foreach (ulong p in primes)
                    for (ulong i = p; i < target + 1; i++)
                        ways[i] += ways[i - p];
                if (ways[target] > limit)
                    break;
                target++;
            }
            return target;
        }
        #endregion
        #region Problem 78
        public ulong Problem78() {
            //http://www.math.temple.edu/~melkamu/html/partition.pdf
            // Euler's formula:
            // P(n) = sum{k=1}^{n}(-1)^{k+1}[P(n-frac(k(3k-1)))+P(n-frac(k(3k+1)))]
            // P(0) = 1
            const long lastDigits = 1000000;
            const long limit = 100000; // should be enough
            long[] p = new long[limit];
            p[0] = 1;
            long n = 0;
            while (p[n] != 0 && n < limit) {
                n++;
                long sum = 0;
                for (long k = 1; k <= n; k++) {
                    long mul = ((k & 1) == 0) ? (-1) : (1);
                    long pos_1 = n - ((3 * k * k - k) / 2); // pentagonal(k)
                    long pos_2 = n - ((3 * k * k + k) / 2); // pentagonal(k)
                    if (pos_1 < 0) break;
                    sum += (pos_1 >= 0) ? (mul * p[pos_1]) : (0);
                    sum += (pos_2 >= 0) ? (mul * p[pos_2]) : (0);
                }
                while (sum < 0)
                    sum += lastDigits;
                p[n] = (sum % lastDigits); // divisible by 1000000
            }
            return (ulong)n;
        }
        #endregion
        #region Problem 79
        public ulong Problem79() {
            using (System.IO.StreamReader reader = new System.IO.StreamReader(@"..\..\..\keylog.txt")) {
                List<int> list = new List<int>();
                while (!reader.EndOfStream) {
                    string line = reader.ReadLine();
                    list.Add(Convert.ToInt32(line));
                }
                // Get digits
                List<int> digits = new List<int>();
                foreach (int i in list) {
                    int n = i;
                    for (int j = 0; j < 3; j++) {
                        int digit = n % 10;
                        if (!digits.Contains(digit))
                            digits.Add(digit);
                        n /= 10;
                    }
                }
                //foreach (int d in digits)
                //    Console.Write(d);
                //Console.WriteLine();
                // Create passcode
                foreach (int i in list) {
                    // digits
                    int d0 = (i / 100); // 1st digit
                    int d1 = (i / 10) % 10; // 2nd digit
                    int d2 = i % 10; // 3rd digit

                    // offsets
                    int o0 = digits.IndexOf(d0);
                    int o1 = digits.IndexOf(d1);
                    int o2 = digits.IndexOf(d2);

                    // check if digits are in right order
                    // if not, swap them
                    if (/*o1 >= 0 &&*/ o0 > o1) {
                        digits[o0] = d1;
                        digits[o1] = d0;
                        // update o1 for next check
                        o1 = o0;
                    }
                    if (/*o2 >= 0 &&*/ o1 > o2) {
                        digits[o1] = d2;
                        digits[o2] = d1;
                    }
                    //Console.Write(i + "->");
                    //foreach (int d in digits)
                    //    Console.Write(d);
                    //Console.WriteLine();
                }
                ulong number = 0;
                foreach (int i in digits)
                    number = number * 10 + (ulong)i;
                return number;
            }
        }
        #endregion
        #region Problem 80
        private string _80_SqrtString(ulong number, int digitsCount) {
            //http://www.afjarvis.staff.shef.ac.uk/maths/jarvisspec02.pdf
            string a = (5 * number).ToString();
            string b = "5";
            while (b.Length < digitsCount) {
                int cmp = CompareNumberAsString(a, b);
                if (cmp > 0) {
                    a = SubString(a, b);
                    b = SumString(b, "10");
                }
                else {
                    a = a + "00";
                    b = b.Substring(0, b.Length - 1) + "05";
                }
            }
            return b;
        }
        public ulong Problem80() {
            const ulong limit = 100;
            const int precision = 100;
            ulong sum = 0;
            for (ulong i = 2; i <= limit; i++) {
                // Only irrational sqrt
                ulong sqrtI = (ulong)(Math.Sqrt(i) + 0.5);
                if (sqrtI * sqrtI == i) continue;
                // Compute sqrt
                string sqrt = _80_SqrtString(i, precision + 5); // add 5 to precision just to be sure
                // Sum digits
                for (int j = 0; j < precision; j++)
                    sum += ToUInt64(sqrt[j]);
            }
            return sum;
        }
        #endregion
        #region Problem 81
        public ulong Problem81() {
            using (System.IO.StreamReader reader = new System.IO.StreamReader(@"..\..\..\matrix_81.txt")) {
                const int size = 80;
                ulong[,] matrix = new ulong[size, size];
                int i = 0;
                while (!reader.EndOfStream) {
                    string s = reader.ReadLine();
                    string[] numbers = s.Split(',');
                    int j = 0;
                    foreach (string number in numbers)
                        matrix[i, j++] = Convert.ToUInt64(number);
                    i++;
                }

                for (int row = size - 1; row >= 0; row--) {
                    for (int column = size - 1; column >= 0; column--) {
                        if (column == size - 1 && row == size - 1) continue;
                        ulong sum1 = matrix[row, column] + (row == size - 1 ? 1000000000 : matrix[row + 1, column]);
                        ulong sum2 = matrix[row, column] + (column == size - 1 ? 1000000000 : matrix[row, column + 1]);
                        matrix[row, column] = Math.Min(sum1, sum2);// sum1 < sum2 ? sum1 : sum2;
                    }
                }
                return matrix[0, 0];
            }
        }
        #endregion
        #region Problem 82
        public ulong Problem82() {
            using (System.IO.StreamReader reader = new System.IO.StreamReader(@"..\..\..\matrix_82.txt")) {
                const int size = 80;
                ulong[,] matrix = new ulong[size, size];
                int row = 0;
                while (!reader.EndOfStream) {
                    string s = reader.ReadLine();
                    string[] numbers = s.Split(',');
                    int column = 0;
                    foreach (string number in numbers)
                        matrix[row, column++] = Convert.ToUInt64(number);
                    row++;
                }

                long best = Int64.MaxValue;
                for (int i = 0; i < size; i++) {
                    // TODO: Inefficient Dijkstra, should use a priority queue instead of find a nearest looping in the matrix
                    // Int64.MaxValue -> future
                    // < 0 -> past
                    // > 0 -> present
                    long[,] dijkstra = new long[size, size];
                    for (int r = 0; r < size; r++)
                        for (int c = 0; c < size; c++)
                            dijkstra[r, c] = Int64.MaxValue;

                    dijkstra[i, 0] = (long)matrix[i, 0];
                    while (true) {
                        // Search for min value and if every node has been visited
                        int minR = 0;
                        int minC = 0;
                        long min = Int64.MaxValue;
                        bool done = true;
                        for (int r = 0; r < size; r++)
                            for (int c = 0; c < size; c++) {
                                if (dijkstra[r, c] > 0)
                                    done = false;
                                if (dijkstra[r, c] > 0 && dijkstra[r, c] < min) {
                                    min = dijkstra[r, c];
                                    minR = r;
                                    minC = c;
                                }
                            }
                        if (done)
                            break;
                        dijkstra[minR, minC] = -dijkstra[minR, minC]; // move to the past
                        if (minC == size - 1) {
                            if ((-dijkstra[minR, minC]) < best)
                                best = (-dijkstra[minR, minC]);
                            break; // stop when right border is reached
                        }
                        for (int v = -1; v <= 1; v++)
                            for (int h = 0; h <= 1; h++) {
                                if (h == 0 && v == 0) continue; // not ourself
                                if (h != 0 && v != 0) continue; // not in diagonal
                                int newR = minR + v;
                                int newC = minC + h;
                                if (newR < 0 || newR >= size || newC < 0 || newC >= size) continue; // out of matrix
                                long dist = Math.Abs(dijkstra[minR, minC]) + Math.Abs((long)matrix[newR, newC]);
                                if (dist < Math.Abs(dijkstra[newR, newC]))
                                    dijkstra[newR, newC] = dist;
                            }
                    }
                }
                return (ulong)best;
            }
        }
        #endregion
        #region Problem 83
        public ulong Problem83() {
            using (System.IO.StreamReader reader = new System.IO.StreamReader(@"..\..\..\matrix_83.txt")) {
                const int size = 80;
                ulong[,] matrix = new ulong[size, size];
                int i = 0;
                while (!reader.EndOfStream) {
                    string s = reader.ReadLine();
                    string[] numbers = s.Split(',');
                    int j = 0;
                    foreach (string number in numbers)
                        matrix[i, j++] = Convert.ToUInt64(number);
                    i++;
                }

                // TODO: Inefficient Dijkstra, should use a priority queue instead of find a nearest looping in the matrix
                // Int64.MaxValue -> future
                // < 0 -> past
                // > 0 -> present
                long[,] dijkstra = new long[size, size];
                for (int r = 0; r < size; r++)
                    for (int c = 0; c < size; c++)
                        dijkstra[r, c] = Int64.MaxValue;

                dijkstra[0, 0] = (long)matrix[0, 0];
                while (true) {
                    // Search for min value and if every node has been visited
                    int minR = 0;
                    int minC = 0;
                    long min = Int64.MaxValue;
                    bool done = true;
                    for (int r = 0; r < size; r++)
                        for (int c = 0; c < size; c++) {
                            if (dijkstra[r, c] > 0)
                                done = false;
                            if (dijkstra[r, c] > 0 && dijkstra[r, c] < min) {
                                min = dijkstra[r, c];
                                minR = r;
                                minC = c;
                            }
                        }
                    if (done)
                        break;
                    dijkstra[minR, minC] = -dijkstra[minR, minC]; // move to the past
                    for (int h = -1; h <= 1; h++)
                        for (int v = -1; v <= 1; v++) {
                            if (h == 0 && v == 0) continue; // not ourself
                            if (h != 0 && v != 0) continue; // not in diagonal
                            int newR = minR + h;
                            int newC = minC + v;
                            if (newR < 0 || newR >= size || newC < 0 || newC >= size) continue; // out of matrix
                            long dist = Math.Abs(dijkstra[minR, minC]) + Math.Abs((long)matrix[newR, newC]);
                            if (dist < Math.Abs(dijkstra[newR, newC]))
                                dijkstra[newR, newC] = dist; // move to present
                        }
                }

                return (ulong)(-dijkstra[size - 1, size - 1]);
            }
        }
        #endregion
        #region Problem 85
        public ulong Problem85() {
            const long limit = 2000000;
            long bestDiff = limit;
            int bestX = 0;
            int bestY = 0;
            for (int x = 2; x <= 100; x++) // should be enough
                for (int y = 2; y <= 100; y++) { // should be enough
                    // Brute-force
                    //long count = 0;
                    //for (int i = 1; i <= y; i++)
                    //    for (int j = 1; j <= x; j++)
                    //        count += (i * j);

                    // sum(i=1->y, sum(j=1->x, i*j))
                    // sum(i=1->y, i*sum(j=1->x, j))
                    // sum(i=1->y, i* x*(x+1)/2)
                    // x*(x+1)/2 * sum(i=1->y, i)
                    // x*(x+1)/2 * y*(y+1)/2
                    long count = (x * (x + 1) * y * (y + 1)) / 4;

                    // Check if closer to limit than previous best solution
                    long diff = Math.Abs(count - limit);
                    if (diff < bestDiff) {
                        bestDiff = diff;
                        bestX = x;
                        bestY = y;
                    }
                }
            return (ulong)(bestX * bestY);
        }
        #endregion
        #region Problem 86
        public ulong Problem86() {
            // Brute-force
            //http://oeis.org/A143715
            //sum(a=1, M, sum(b=a, M, sum(c=b, M, issquare((a+b)^2+c^2))))
            //ulong limit = 2000;
            //ulong size = (ulong)(Math.Sqrt(limit) + 0.5); // arbitrary lower limit
            //while (true) {
            //    ulong count = 0;
            //    for (ulong a = 1; a <= size; a++) {
            //        for (ulong b = a; b <= size; b++)
            //            for (ulong c = b; c <= size; c++)
            //                if (IsPerfectSquare((a + b) * (a + b) + c * c))
            //                    count++;
            //    }
            //    if (count >= limit) {
            //        //Console.WriteLine(limit + "->" + size + " [" + count + "]" + 2.125 * Math.Sqrt(limit));
            //        break;
            //    }
            //    size++;
            //}

            //const ulong limit = 1000000;
            //ulong size = 1;
            //ulong count = 0;
            //while (true) {
            //    for (ulong i = 1; i <= size; i++)
            //        for (ulong j = 1; j <= i; j++) {
            //            //a = (size + j) * (size + j) + i * i; (1)
            //            //b = (size + i) * (size + i) + j * j; (2)
            //            //a = b < a ? b : a; (3)
            //            //b = (i + j) * (i + j) + size * size; (4)
            //            //a = b < a ? b : a; (5)
            //            //b = (ulong)Math.Sqrt(a);

            //            // 1) a <= b because j <= i   b is never computed/used in (2) and (3)
            //            // 2) (size + j) * (size + j) + i * i < (i + j) * (i + j) + size * size  if i < size   b is computed only if i < size in (4)
            //            // 3) else i == size, (size + j) * (size + j) + i * i => (i + j) * (i + j) + s * s    b is never computed/used in (4) and (5)
            //            ulong squaredDist = (i + j) * (i + j) + size * size;
            //            if (IsPerfectSquare(squaredDist))
            //                count++;
            //        }
            //    if (count >= limit)
            //        break;
            //    size++;
            //}
            //return (ulong)size;

            ulong limit = 1000000;
            ulong sum = 0;
            ulong size = 1;
            while (true) {
                for (ulong a = 1; a <= 2 * size; a++)
                    if (IsPerfectSquare(a * a + size * size))
                        if (a > size)
                            sum += a / 2 - (a - size - 1);
                        else
                            sum += a / 2;
                if (sum >= limit)
                    break;
                size++;
            }
            return size;
        }
        #endregion
        #region Problem 87
        public ulong Problem87() {
            const ulong limit = 50000000;
            const ulong sieveLimit = 10000;
            bool[] sieve = BuildSieve(sieveLimit);
            Dictionary<ulong, bool> answer = new Dictionary<ulong, bool>();
            ulong count = 0;
            for (ulong i = 2; i < sieveLimit; i++) {
                if (sieve[i]) continue; // not a prime
                ulong ii = i * i; // square
                if (ii >= limit) continue; // not a prime
                for (ulong j = 2; j < sieveLimit; j++) {
                    if (sieve[j]) continue; // not a prime
                    ulong jjj = j * j * j; // cube
                    if (ii + jjj >= limit) continue;
                    for (ulong k = 2; k < sieveLimit; k++) {
                        if (sieve[k]) continue; // not a prime
                        ulong kkkk = k * k * k * k; // fourth power
                        ulong sum = ii + jjj + kkkk;
                        if (sum >= limit) continue;
                        if (answer.ContainsKey(sum)) continue; // already found
                        answer.Add(sum, true);
                        count++;
                    }
                }
            }
            return count;
        }
        #endregion
        #region Problem 89
        public ulong Problem89() {
            using (System.IO.StreamReader reader = new System.IO.StreamReader(@"..\..\..\roman.txt")) {
                ulong count = 0;
                ulong compressedCount = 0;
                while (!reader.EndOfStream) {
                    string s = reader.ReadLine();
                    count += (ulong)s.Length;
                    string t = s.Replace("VIIII", "IX").Replace("IIII", "IV").Replace("LXXXX", "XC").Replace("XXXX", "XL").Replace("DCCCC", "CM").Replace("CCCC", "CD");
                    compressedCount += (ulong)t.Length;
                }
                return count - compressedCount;
            }
        }
        #endregion
        #region Problem 90
        private bool _90_IsValid(string d1, string d2) {
            if (!((d1.Contains("0") && d2.Contains("1")) || (d2.Contains("0") && d1.Contains("1"))))
                return false;
            if (!((d1.Contains("0") && d2.Contains("4")) || (d2.Contains("0") && d1.Contains("4"))))
                return false;
            if (!((d1.Contains("0") && (d2.Contains("6") || d2.Contains("9"))) || (d2.Contains("0") && (d1.Contains("6") || d1.Contains("9")))))
                return false;
            if (!((d1.Contains("1") && (d2.Contains("6") || d2.Contains("9"))) || (d2.Contains("1") && (d1.Contains("6") || d1.Contains("9")))))
                return false;
            if (!((d1.Contains("2") && d2.Contains("5")) || (d2.Contains("2") && d1.Contains("5"))))
                return false;
            if (!((d1.Contains("3") && (d2.Contains("6") || d2.Contains("9"))) || (d2.Contains("3") && (d1.Contains("6") || d1.Contains("9")))))
                return false;
            if (!((d1.Contains("4") && (d2.Contains("6") || d2.Contains("9"))) || (d2.Contains("4") && (d1.Contains("6") || d1.Contains("9")))))
                return false;
            if (!((d1.Contains("8") && d2.Contains("1")) || (d2.Contains("8") && d1.Contains("1"))))
                return false;
            return true;
        }
        public ulong Problem90() {
            ulong count = 0;
            for (int a = 0; a <= 9; a++)
                for (int b = a + 1; b <= 9; b++)
                    for (int c = b + 1; c <= 9; c++)
                        for (int d = c + 1; d <= 9; d++)
                            for (int e = d + 1; e <= 9; e++)
                                for (int f = e + 1; f <= 9; f++)
                                    for (int g = 0; g <= 9; g++)
                                        for (int h = g + 1; h <= 9; h++)
                                            for (int i = h + 1; i <= 9; i++)
                                                for (int j = i + 1; j <= 9; j++)
                                                    for (int k = j + 1; k <= 9; k++)
                                                        for (int l = k + 1; l <= 9; l++) {
                                                            string d1 = a.ToString() + b.ToString() + c.ToString() + d.ToString() + e.ToString() + f.ToString();
                                                            string d2 = g.ToString() + h.ToString() + i.ToString() + j.ToString() + k.ToString() + l.ToString();
                                                            if (_90_IsValid(d1, d2)) {
                                                                count++;
                                                            }
                                                        }

            return count / 2;
        }
        #endregion
        #region Problem 92
        private ulong _92_SumSquareDigits(ulong number) {
            ulong sum = 0;
            while (number >= 1) {
                ulong digit = number % 10;
                sum += digit * digit;
                number /= 10;
            }
            return sum;
        }
        public ulong Problem92() {
            const ulong limit = 10000000;
            Dictionary<ulong, ulong> list89 = new Dictionary<ulong, ulong>();
            Dictionary<ulong, ulong> list1 = new Dictionary<ulong, ulong>();
            list89.Add(89, 89);
            list1.Add(1, 1);
            ulong count = 0;
            for (ulong n = 2; n <= limit; n++) {
                if (list89.ContainsKey(n)) {
                    count++;
                    continue;
                }
                if (list1.ContainsKey(n)) continue;

                List<ulong> list = new List<ulong>();
                ulong i = n;
                while (true) {
                    i = _92_SumSquareDigits(i);
                    if (i == 89 || list89.ContainsKey(i)) {
                        count++;
                        foreach (ulong item in list)
                            list89.Add(item, item);
                        break;
                    }
                    else if (i == 1 || list1.ContainsKey(i)) {
                        foreach (ulong item in list)
                            list1.Add(item, item);
                        break;
                    }
                    list.Add(i); // No need to store n, we store only after the first sum
                }
            }
            return count;
        }
        #endregion
        #region Problem 94
        public ulong Problem94() {
            // Brute-force
            // perimeter = 2*a+b with b=a+1 or b=a-1
            // area = 1/4 * ( 3a # 1 ) * sqrt( ( a # 1 )^2 * ( a | 1 ) )  with # representing + (b=a+1) or - (b=a-1) and  | representing - (b=a+1) or + (b=a-1)
            const ulong perimeterLimit = 1000000000;
            const ulong sideLimit = 1 + (1000000000 / 3);
            ulong count = 1;
            ulong sum = 0;
            for (ulong a = 3; a <= sideLimit; a += 2) {
                //if (a % 1000000 == 0)
                //    Console.WriteLine("a:" + a + " count:" + count + " sum: "+sum);
                ulong b1 = a + 1;
                ulong perimeter1 = 2 * a + b1;
                ulong toTest1 = (4 * a * a - b1 * b1); // a^2 - (b/2)^2 = height of the triangle with base b
                if (0 == (toTest1 % 4)) {
                    bool fIntegral1 = IsPerfectSquare(toTest1 / 4);
                    if (perimeter1 <= perimeterLimit && fIntegral1) {
                        //Console.WriteLine("+1 --> a=" + a + " b=" + b1 + " p=" + perimeter1);
                        sum += perimeter1;
                        count++;
                        continue; // no need to test second case
                    }
                }
                ulong b2 = a - 1;
                ulong perimeter2 = 2 * a + b2;
                ulong toTest2 = (4 * a * a - b2 * b2); // a^2 - (b/2)^2 = height of the triangle with base b
                if (0 == (toTest2 % 4)) {
                    bool fIntegral2 = IsPerfectSquare(toTest2 / 4);
                    if (perimeter2 <= perimeterLimit && fIntegral2) {
                        //Console.WriteLine("-1 --> a=" + a + " b=" + b2 + " p=" + perimeter2);
                        sum += perimeter2;
                        count++;
                    }
                }
            }
            return sum;
            // Fast method: http://oeis.org/A120893
        }
        #endregion
        #region Problem 95
        private bool _95_CheckChain(ulong limit, ulong[] divisorsSum, ulong[] chain, ulong n, out ulong smallest, out ulong length) {
            ulong i = n;
            length = 1;
            smallest = limit;
            chain[n] = n;
            while (true) {
                i = divisorsSum[i];
                smallest = (smallest > i) ? i : smallest;
                if (i > limit) return false;
                if (chain[i] == n) {
                    if (i == n) return true;
                    return false;
                }
                chain[i] = n;
                length++;
            }
        }
        public ulong Problem95() {
            //ulong limit = 1000000;
            //ulong longestLength = 0;
            //ulong smallestOfLongestLength = 0;
            //ulong[] chain = new ulong[limit];
            //for (int idx = 0; idx < chain.Length; idx++)
            //    chain[idx] = 0;
            //ulong i = 10;
            //while (true) {
            //    if (i >= limit)
            //        break;
            //    bool fChain = false;
            //    ulong chainLength = 0;
            //    ulong smallest = i;
            //    if (0 == chain[i]) {
            //        // Build list of sum of proper divisors
            //        bool fTooBig = false;
            //        List<ulong> list = new List<ulong>();
            //        ulong n = i;
            //        while (true) {
            //            chainLength++;
            //            ulong nPrevious = n;
            //            list.Add(n);
            //            n = SumOfProperDivisors(n);
            //            if (n >= limit) {
            //                fTooBig = true;
            //                break;
            //            }
            //            if (n < smallest)
            //                smallest = n;
            //            if (n == i) { // stops if a circular chain is found
            //                fChain = true;
            //                break;
            //            }
            //            if (1 == n) // stops when a prime number is found
            //                break;
            //            if (list.Contains(n)) // stops if number already found in this loop
            //                break;
            //        }
            //        if (!fTooBig) {
            //            for (int idx = 0; idx < list.Count - 1; idx++) {
            //                int next = (idx + 1) % list.Count;
            //                chain[list[idx]] = list[next];
            //            }
            //            chain[list[list.Count - 1]] = n;
            //        }
            //    }
            //    else {
            //        // Number already found, check if circular chain
            //        ulong index = i;
            //        smallest = i;
            //        List<ulong> list = new List<ulong>();
            //        while (true) {
            //            list.Add(index);
            //            chainLength++;
            //            if (index < smallest)
            //                smallest = index;
            //            ulong previousIndex = index;
            //            index = chain[index];
            //            if (index == i) { // true cycle
            //                fChain = true;
            //                break;
            //            }
            //            if (list.Contains(index)) { // false cycle
            //                fChain = false;
            //                break;
            //            }
            //            if (index == 1) { // chain ended by a prime number
            //                fChain = false;
            //                break;
            //            }
            //        }
            //    }
            //    if (fChain) { // circular chain
            //        //if ((ulong)list.Count > longestLength) {
            //        //    longestLength = (ulong)list.Count;
            //        //    ulong smallest = ulong.MaxValue;
            //        //    foreach (ulong item in list)
            //        //        if (item < smallest)
            //        //            smallest = item;
            //        //    smallestOfLongestLength = smallest;
            //        //}
            //        if (chainLength > longestLength) {
            //            longestLength = chainLength;
            //            smallestOfLongestLength = smallest;
            //        }
            //    }
            //    i++;
            //}
            //return smallestOfLongestLength;
            const ulong limit = 1000000;
            ulong[] divisorsSum = new ulong[limit];
            // Modified sieve
            for (ulong i = 0; i < limit; i++)
                divisorsSum[i] = 1;
            for (ulong factor = 2; factor < limit / 2; factor++)
                for (ulong mult = 2; factor * mult < limit; mult++)
                    divisorsSum[factor * mult] += factor;
            // Build chains
            ulong[] chain = new ulong[limit];
            for (ulong i = 0; i < limit; i++)
                chain[i] = 0;
            ulong index = 0;
            ulong longest = 0;
            ulong smallestOfLongestLength = 0;
            for (ulong i = 2; i < limit; i++) {
                ulong smallest, length;
                bool fCheckChain = _95_CheckChain(limit, divisorsSum, chain, i, out smallest, out length);
                if (fCheckChain && length > longest) {
                    longest = length;
                    index = i;
                    smallestOfLongestLength = smallest;
                }
            }
            return smallestOfLongestLength;
        }
        #endregion
        #region Problem 97
        public ulong Problem97() {
            // (a*a*a)%n = ((a%n)*(a%n)*(a%n)) %n
            const ulong last10digits = 10000000000;
            ulong number = (1 + 28433 * PowModulo(2, 7830457, last10digits)) % last10digits;
            return number;
        }
        #endregion
        #region Problem 99
        public ulong Problem99() {
            // a^b > c^d  <==> b*ln(a) > d*ln(c) with a, b, c, d > 1
            using (System.IO.StreamReader reader = new System.IO.StreamReader(@"..\..\..\base_exp.txt")) {
                int lineNumber = 1;
                double bestPower = 1;
                int bestLineNumber = 1;
                while (!reader.EndOfStream) {
                    string s = reader.ReadLine();
                    string[] tokens = s.Split(',');
                    ulong b = Convert.ToUInt64(tokens[0]);
                    ulong e = Convert.ToUInt64(tokens[1]);
                    double power = e * Math.Log(b);
                    if (power > bestPower) {
                        bestPower = power;
                        bestLineNumber = lineNumber;
                    }
                    lineNumber++;
                }
                return (ulong)bestLineNumber;
            }
        }
        #endregion
        #region Problem 100
        public ulong Problem100() {
            // (b/t)*(b-1)/(t-1) = 1/2   b for blue discs   t for total discs
            // 2b^2 – 2b – t^2 + t = 0

            //// Brute-force
            //// b = (1+sqrt(1+2*t*t-2*t))/2
            //// must find sqrt(1+2*t*t-2*t) integral with t > 10^12
            //// first iterations gives a constant ratio, so we can get a lower bound for the next value
            //const ulong limit = 1000000000000;
            //ulong b = 0;
            //ulong previous = 120;
            //ulong t = 121;
            //while (true) {
            //    ulong n = 1 + 2 * t * t - 2 * t;
            //    ulong sqrt = (ulong)Math.Sqrt(n);
            //    if (sqrt * sqrt == n) {
            //        if (t > limit) {
            //            b = (1 + sqrt) / 2;
            //            break;
            //        }
            //        ulong tmp = t;
            //        t = t * t / previous;
            //        previous = tmp;
            //    }
            //    else
            //        t++;
            //}
            //return b;

            // diophantine quadratic equation -> http://www.alpertron.com.ar/QUAD.HTM to get the coefficient
            //X0 = 1
            //Y0 = 1
            //Xn+1 = P Xn + Q Yn + K
            //Yn+1 = R Xn + S Yn + L
            //P = 3
            //Q = 2
            //K = -2
            //R = 4
            //S = 3
            //L = -3
            // blue disks = 3b + 2t – 2
            // total disc = 4b + 3t - 3
            ulong limit = Convert.ToUInt64("1000000000000");
            ulong b = 85;
            ulong t = 120;
            while (t < limit) {
                ulong newB = 3 * b + 2 * t - 2;
                ulong newT = 4 * b + 3 * t - 3;
                b = newB;
                t = newT;
            }
            return b;
        }
        #endregion
        #region Problem 102
        private long _102_DotProduct(long ax, long ay, long bx, long by) {
            return ax * bx + ay * by;
        }
        private bool _102_PointInsideTriangle(long ax, long ay, long bx, long by, long cx, long cy, long px, long py) {
            //http://www.blackpawn.com/texts/pointinpoly/default.html
            // Compute vectors
            long v0x = cx - ax;
            long v0y = cy - ay;
            long v1x = bx - ax;
            long v1y = by - ay;
            long v2x = px - ax;
            long v2y = py - ay;

            // Compute dot products
            long dot00 = _102_DotProduct(v0x, v0y, v0x, v0y);
            long dot01 = _102_DotProduct(v0x, v0y, v1x, v1y);
            long dot02 = _102_DotProduct(v0x, v0y, v2x, v2y);
            long dot11 = _102_DotProduct(v1x, v1y, v1x, v1y);
            long dot12 = _102_DotProduct(v1x, v1y, v2x, v2y);

            // Compute barycentric coordinates
            double u = (double)(dot11 * dot02 - dot01 * dot12) / (double)(dot00 * dot11 - dot01 * dot01);
            double v = (double)(dot00 * dot12 - dot01 * dot02) / (double)(dot00 * dot11 - dot01 * dot01);

            // Check if point is in triangle
            return (u > 0) && (v > 0) && (u + v < 1);
        }
        public ulong Problem102() {
            using (System.IO.StreamReader reader = new System.IO.StreamReader(@"..\..\..\triangles.txt")) {
                ulong count = 0;
                while (!reader.EndOfStream) {
                    string s = reader.ReadLine();
                    string[] tokens = s.Split(',');
                    long ax = Convert.ToInt64(tokens[0]);
                    long ay = Convert.ToInt64(tokens[1]);
                    long bx = Convert.ToInt64(tokens[2]);
                    long by = Convert.ToInt64(tokens[3]);
                    long cx = Convert.ToInt64(tokens[4]);
                    long cy = Convert.ToInt64(tokens[5]);
                    bool fIsInTriangle = _102_PointInsideTriangle(ax, ay, bx, by, cx, cy, 0, 0);
                    if (fIsInTriangle)
                        count++;
                }
                return count;
            }
        }
        #endregion
        #region Problem 103
        private void _103_DoStuff(ulong[] mins, ulong[] maxs, ulong[] nums, int index, ref ulong bestSum, ref ulong bestSet) {
            for (ulong i = mins[index]; i <= maxs[index]; i++) {
                nums[index] = i;
                if (index < mins.Length - 1)
                    _103_DoStuff(mins, maxs, nums, index + 1, ref bestSum, ref bestSet);
                else {
                    //foreach (ulong n in nums)
                    //    Console.Write(" " + n);
                    //Console.WriteLine();
                    if (IsSpecialSet(nums)) {
                        ulong sum = 0;
                        foreach (ulong n in nums)
                            sum += n;
                        if (sum < bestSum) {
                            StringBuilder s = new StringBuilder(7 * 2);
                            foreach (ulong n in nums)
                                s.Append(n.ToString());
                            bestSet = Convert.ToUInt64(s.ToString());
                            bestSum = sum;
                        }
                    }
                }
            }
        }
        public ulong Problem103() {
            // min = near_optimal - 1
            ulong[] mins = new ulong[] { 19, 30, 37, 38, 39, 41, 44 };
            // max = near_optimal + 1
            ulong[] maxs = new ulong[] { 21, 32, 39, 40, 41, 43, 46 };
            ulong[] nums = new ulong[] { 19, 30, 37, 38, 39, 41, 44 };
            ulong bestSum = UInt64.MaxValue;
            ulong bestSet = 0;
            _103_DoStuff(mins, maxs, nums, 0, ref bestSum, ref bestSet);
            return bestSet;
        }
        #endregion
        #region Problem 104
        public ulong Problem104() {
            // Brute-force too slow
            //string fn = "1";
            //string fn_1 = "1";
            //ulong n = 2;
            //while (true) {
            //    string fn_2 = SumString(fn, fn_1);
            //    n++;
            //    if (fn_2.Length > 9 && IsPandigital(fn_2.Substring(fn_2.Length - 9)) && IsPandigital(fn_2.Substring(0,9)))
            //        break;
            //    fn = fn_1;
            //    fn_1 = fn_2;
            //}
            //return n;

            const ulong limit = 1000000; // arbitrary limit
            const ulong last9Digits = 1000000000;
            double log10Phi = Math.Log10((1.0 + Math.Sqrt(5)) / 2.0);
            double log10Multiplier = Math.Log10(1.0 / Math.Sqrt(5));
            ulong fn = 1;
            ulong fn_1 = 1;
            for (ulong n = 3; n <= limit; n++) {
                ulong fn_2 = (fn + fn_1) % last9Digits; // last 9 digits
                string s = fn_2.ToString();
                if (s.Length >= 9 && IsPandigital(s)) {
                    // Last 9 digits matches, check first 9 digits
                    // Compute first 9 digits of Fn for each right-pandigital
                    // if log(n) = xxxxx.yyyyy
                    // n = 10^(xxxxx.yyyyy)
                    // n = 10^(xxxxx+0.yyyyy)
                    // n = 10^xxxxx * 10^0.yyyyy
                    // first part is a power of 10 so it just gives where to put the decimal point
                    // second part contains the number itself
                    // 0.yyyyy is between 0 and 1, so 10^0.yyyyy is between 1 and 10
                    // 10^0.yyyyy gives the number z.zzzzzz
                    // we want the 9 first digits, so we have to multiply z.zzzzz by 10^(9-1)
                    // 9 first digits:
                    // 10^8 * 10^frac(log10(n))
                    // or 10^[frac(log10(n)) + 8]
                    double t = (double)n * log10Phi + log10Multiplier; // Log10(Fn)
                    double f = t - Math.Floor(t); // frac(t)
                    ulong first9digits = (ulong)Math.Pow(10.0, f + 9 - 1);
                    if (IsPandigital(first9digits.ToString()))
                        return n;
                }
                fn = fn_1;
                fn_1 = fn_2;
            }
            return 0;
        }
        #endregion
        #region Problem 105
        public ulong Problem105() {
            using (System.IO.StreamReader reader = new System.IO.StreamReader(@"..\..\..\sets_105.txt")) {
                ulong total = 0;
                while (!reader.EndOfStream) {
                    string s = reader.ReadLine();
                    string[] numbers = s.Split(',');
                    ulong[] set = new ulong[numbers.Length];
                    int idx = 0;
                    foreach (string number in numbers)
                        set[idx++] = Convert.ToUInt64(number);
                    if (IsSpecialSet(set))
                        foreach (ulong val in set)
                            total += val;
                }
                return total;
            }
        }
        #endregion
        #region Problem 107
        private void _107_UpdateDistances(int size, ulong[,] matrix, ulong[] d/*, int[] whoTo*/, int target) {
            for (int i = 0; i < size; ++i)
                if ((matrix[target, i] != 0) && (d[i] > matrix[target, i])) {
                    d[i] = matrix[target, i];
                    /*whoTo[i] = target;*/
                }

        }
        public ulong Problem107() {
            using (System.IO.StreamReader reader = new System.IO.StreamReader(@"..\..\..\network.txt")) {
                const int size = 40;
                ulong[,] matrix = new ulong[size, size];
                int r = 0;
                while (!reader.EndOfStream) {
                    string s = reader.ReadLine();
                    string[] numbers = s.Split(',');
                    int c = 0;
                    foreach (string number in numbers) {
                        if (0 == number.CompareTo("-"))
                            matrix[r, c] = 0;
                        else
                            matrix[r, c] = Convert.ToUInt64(number);
                        c++;
                    }
                    r++;
                }

                // Count total distance
                ulong total = 0;
                for (int i = 0; i < size; i++)
                    for (int j = 0; j < i; j++)
                        total += matrix[i, j];

                // Prim
                bool[] inTree = new bool[size];
                ulong[] d = new ulong[size];
                //int[] whoTo = new int[size];

                // Init
                for (int i = 0; i < size; i++) {
                    d[i] = ulong.MaxValue; // Initialize with Infinity
                    inTree[i] = false; // Not in spanning tree
                    //whoTo[i] = -1;
                }
                // Add first node to the tree
                inTree[0] = true;
                _107_UpdateDistances(size, matrix, d, 0);

                // Algo
                ulong totalOptimized = 0;
                for (int treeSize = 1; treeSize < size; treeSize++) {
                    // Find the node with the smallest distance to the tree
                    int min = -1;
                    for (int i = 0; i < size; i++)
                        if (!inTree[i])
                            if (min == -1 || d[min] > d[i])
                                min = i;
                    // Add it
                    inTree[min] = true;
                    totalOptimized += d[min];

                    // Update
                    _107_UpdateDistances(size, matrix, d, min);
                }

                return total - totalOptimized;
            }
        }
        #endregion
        #region Problem 108
        private ulong _108_FactorOfSquareCount(ulong n) {
            ulong sqrtN = (ulong)Math.Sqrt(n);
            ulong count = 1;
            for (ulong i = 2; i <= sqrtN; i++) {
                if (0 == (n % i)) {
                    ulong exponentCount = 0;
                    while ((n % i) == 0) {
                        exponentCount++;
                        n /= i;
                    }
                    count *= 2 * exponentCount + 1;
                }
                if (0 == n)
                    break;
            }
            return count;
        }
        public ulong Problem108() {
            // Brute-force
            //ulong limit = 20000;
            //SortedDictionary<ulong, int> dict = new SortedDictionary<ulong, int>();
            //for ( ulong x = 2; x <= limit; x++ )
            //    for (ulong y = x; y <= limit; y++) {
            //        ulong remainderN = (x * y) % (x + y);
            //        if (0 == remainderN) {
            //            ulong n = (x * y) / (x + y);
            //            if (dict.ContainsKey(n))
            //                dict[n]++;
            //            else
            //                dict.Add(n, 1);
            //        }
            //    }
            //// dict.Count = limit/2
            //foreach (KeyValuePair<ulong, int> kv in dict) {
            //    if (kv.Value >= 1000)
            //        return kv.Key;
            //}
            //return 0;

            // 1/x + 1/y = 1/n
            // y = n + n^2/(x-n)   n < x <= 2n   y integral if x-n divide n^2
            // if d is a factor of n^2 and n < d+n <= 2n
            // if we analyse n=4, n=5 and n=6, #solution = (#factor(n^2)+1)/2
            // if n = p1^e1 * p2^e2 * p3^e3
            // #factor(n) = (e1+1)*(e2+1)*(e3+1)
            // n^2 = p1^2e1 * p2^2e2 * p3^2e3
            // #factor(n^2) = (2*e1+1)*(2*e2+1)*(2*e3+1)
            ulong bestN = 0;
            ulong n = 1260;
            while (true) {
                ulong solutionCount = (_108_FactorOfSquareCount(n) + 1) / 2;
                if (solutionCount > 1000) {
                    bestN = n;
                    break;
                }
                n++;
            }
            return bestN;
        }
        #endregion
        #region Problem 110
        private ulong _110_ProductPrimesExponent(ulong[] primes, ulong factorsCount, ulong maxExponent, ulong startingPrimeIndex) {
            if (factorsCount <= 1)
                return 1;
            if (factorsCount <= 3)
                return primes[startingPrimeIndex];
            ulong pPow = primes[startingPrimeIndex];
            ulong best = pPow * _110_ProductPrimesExponent(primes, (factorsCount + 2) / 3, 1, startingPrimeIndex + 1);
            for (ulong exponent = 2; exponent <= maxExponent; exponent++) {
                pPow *= primes[startingPrimeIndex];
                if (pPow > best)
                    break;
                ulong test = pPow * _110_ProductPrimesExponent(primes, (factorsCount + 2 * exponent) / (2 * exponent + 1), exponent, startingPrimeIndex + 1);
                if (test < best)
                    best = test;
            }
            return best;
        }
        private ulong _110_FactorOfSquareCount(ulong[] primes, ulong n) {
            ulong count = 1;
            int idx = 0;
            while (n > 1) {
                if (idx >= primes.Length)
                    break; // not a solution if we need a really high prime
                if (0 == (n % primes[idx])) {
                    ulong exponentCount = 0;
                    while ((n % primes[idx]) == 0) {
                        exponentCount++;
                        n /= primes[idx];
                    }
                    count *= 2 * exponentCount + 1;
                }
                if (0 == n)
                    break;
                idx++;
            }
            return count;
        }
        public ulong Problem110() {
            // TODO: optimise using http://www.mathpages.com/home/kmath332.htm and http://oeis.org/A018892

            // Compute first primes
            const int primesCount = 10000;
            ulong[] primes = new ulong[primesCount];
            primes[0] = 2;
            int idx = 1;
            while (idx < primesCount) {
                primes[idx] = primes[idx - 1] + 1;
                while (!IsPrime(primes[idx]))
                    primes[idx]++;
                idx++;
            }
            // Use dichotomy to find the solution
            ulong limit = 4000000;
            ulong solution = 0;
            ulong n = 1000;
            ulong increment = 1;
            while (true) {
                //Console.WriteLine(n + "  " + increment);
                ulong number = _110_ProductPrimesExponent(primes, n, 50, 0);
                ulong count = (_110_FactorOfSquareCount(primes, number) + 1) / 2;
                if (count >= limit) {
                    if (1 == increment) { // if limit is reached and increment = 1, solution found
                        solution = number;
                        break;
                    }
                    else {
                        n -= increment; // if limit is reached but increment > 1, went to high, restart from current - increment and reset increment
                        increment = 1;
                    }
                }
                else
                    increment *= 2;
                n += increment;
            }
            return solution;
        }
        #endregion
        #region Problem 111
        private void _111_Permutation(StringBuilder sb, int digitCount, ulong lowerLimit, ulong upperLimit, int baseDigit, int numberOfDigitToModify, int position, ref ulong count, ref ulong sum) {
            // sb: base number
            // digitCount: number of digit in number
            // lower/upperLimit: number must be within these limits (avoid leading 0)
            // baseDigit: in the beginning sb is filled with baseDigit
            // numberOfDigitToModify: number of digits modified
            // position: position of the last modified digit
            // count: number of prime found
            // sum: sum of prime found
            for (int pos = position; pos < digitCount; pos++) {
                for (int digit = 0; digit < 10; digit++)
                    if (digit != baseDigit) {
                        sb[pos] = Convert.ToChar(digit + 48); // change digit
                        if (numberOfDigitToModify > 1) { // recursive call if more than one digit left to modify
                            _111_Permutation(sb, digitCount, lowerLimit, upperLimit, baseDigit, numberOfDigitToModify - 1, pos + 1, ref count, ref sum);
                        }
                        else {
                            // Check if in limits and prime
                            ulong n = Convert.ToUInt64(sb.ToString());
                            if (n >= lowerLimit && n <= upperLimit) {
                                if (IsPrime(n)) {
                                    //Console.WriteLine(n);
                                    count++;
                                    sum += n;
                                }
                            }
                        }
                    }
                sb[pos] = Convert.ToChar(baseDigit + 48); // reset digit
            }
        }
        public ulong Problem111() {
            // For each digit
            //  Build number with repeating 10 digits
            //  modify 1 digit, if prime count == 0, modify 2 digits, ...
            //  until prime count > 0
            const ulong lowerLimit = 1000000000;
            const ulong upperLimit = 9999999999;
            int digitCount = 10;
            ulong globalSum = 0;
            for (int digit = 0; digit < 10; digit++) {
                StringBuilder sb = new StringBuilder();
                for (int j = 0; j < digitCount; j++)
                    sb.Append(digit); // fill number with digit
                ulong count = 0;
                ulong sum = 0;
                for (int numberOfDigitToModify = 1; numberOfDigitToModify < 10; numberOfDigitToModify++) {
                    _111_Permutation(sb, digitCount, lowerLimit, upperLimit, digit, numberOfDigitToModify, 0, ref count, ref sum);
                    if (count > 0)
                        break;
                }
                globalSum += sum;
                //Console.WriteLine(digit + "->" + count + " " + sum);
            }
            return globalSum;
        }
        #endregion
        #region Problem 112
        public ulong Problem112() {
            ulong n = 100; // no bouncy below 100
            ulong count = 0;
            while (true) {
                string s = n.ToString();
                // Increasing/Decreasing
                bool fIncreasing = true;
                bool fDecreasing = true;
                for (int i = 1; i < s.Length; i++) {
                    if (s[i] < s[i - 1])
                        fIncreasing = false;
                    if (s[i] > s[i - 1])
                        fDecreasing = false;
                    if (!fDecreasing && !fIncreasing)
                        break;
                }
                if (!fIncreasing && !fDecreasing)
                    count++;
                if (100 * count >= 99 * n)
                    break;
                n++;
            }
            return n;
        }
        #endregion
        #region Problem 113
        private ulong _113_IncNum(ulong[,] incCount, int leftDigit, int numOfDigits) {
            if (0 == incCount[leftDigit, numOfDigits])
                if (1 == numOfDigits)
                    incCount[leftDigit, numOfDigits] = (ulong)(10 - leftDigit);
                else
                    for (int i = leftDigit; i < 10; i++)
                        incCount[leftDigit, numOfDigits] += _113_IncNum(incCount, i, numOfDigits - 1);
            return incCount[leftDigit, numOfDigits];
        }
        private ulong _113_DecNum(ulong[,] decCount, int leftDigit, int numOfDigits) {
            if (0 == decCount[leftDigit, numOfDigits])
                if (1 == numOfDigits)
                    decCount[leftDigit, numOfDigits] = (ulong)(leftDigit + 1);
                else
                    for (int i = leftDigit; i >= 0; i--)
                        decCount[leftDigit, numOfDigits] += _113_DecNum(decCount, i, numOfDigits - 1);
            return decCount[leftDigit, numOfDigits];
        }
        public ulong Problem113() {
            const int numOfDigits = 100; // 10^100 (a gogol) has 100 digits
            ulong[,] incCount = new ulong[10, numOfDigits + 1]; // 2nd index 0 not used
            ulong[,] decCount = new ulong[10, numOfDigits + 1]; // 2nd index 0 not used
            ulong count = 0;
            for (int i = 1; i <= numOfDigits; i++)
                count += _113_IncNum(incCount, 1, i) + _113_DecNum(decCount, 9, i) - 10;
            return count;
        }
        #endregion
        #region Problem 118
        private void _118_Extract(string permutation, List<ulong> set, Dictionary<string, int> results) {
            for (int length = 1; length <= permutation.Length; length++) {
                ulong n = Convert.ToUInt64(permutation.Substring(0, length));
                if (!IsPrime(n))
                    continue; // If it's not a prime, take a bigger substring
                set.Add(n); // Push
                if (length == permutation.Length) {
                    // Sort set
                    List<ulong> sorted = new List<ulong>(set);
                    sorted.Sort();
                    // Create string correponding to set
                    string sortedAsString = "";
                    foreach (ulong item in sorted)
                        sortedAsString += "(" + item.ToString() + ")";
                    // Insert string if not already found
                    if (!results.ContainsKey(sortedAsString))
                        results.Add(sortedAsString, 1);
                    else
                        results[sortedAsString]++; // Or increment occurence
                }
                else {
                    // Recursive call with the remaining string
                    string remaining = permutation.Substring(length);
                    _118_Extract(remaining, set, results);
                }
                set.RemoveAt(set.Count - 1); // Pop
            }
        }
        public ulong Problem118() {
            // Generate every pandigital permutations
            // Foreach permutation, try to extract prime starting from front
            // If able to extract prime till the end of the permutation, store in a set as string in a dictionary
            Dictionary<string, int> results = new Dictionary<string, int>();
            string[] permutations = Permutations("123456789");
            foreach (string permutation in permutations) {
                List<ulong> set = new List<ulong>();
                _118_Extract(permutation, set, results);
            }
            return (ulong)results.Count;
        }
        #endregion
        #region Problem 119
        public string Problem119() {
            // Compute a^b (arbitrary limit for a and b) until we have found 40 results. Sort these results and hope the 30th will be the right one :p
            string[] results = new string[40];
            int idx = 0;
            for (uint a = 2; a <= 100; a++)
                for (uint b = 2; b <= 50; b++) {
                    BigInt p = BigInt.Power(a, b);
                    string s = p.ToString();
                    ulong sumDigits = SumDigits(s);
                    if (a == sumDigits)
                        results[idx++] = s;
                    if (idx == results.Length)
                        break;
                }
            Array.Sort(results, CompareNumberAsString);
            return results[29];
        }
        #endregion
        #region Problem 120
        public ulong Problem120() {
            // ((a-1)^n + (a+1)^n)/a^2
            // using binomial theorem
            // sum[ Cnk a^(n-k) (-1)^k ] + sum[ Cnk a^(n-k) (1)^k ]
            // if n == 1, (a-1 + a+1)/a^2 => 2a / a^2           remainder is 2a
            // if n is even, terms with a^(k<n) are simplified
            //      (2*a^n + 2*(1)^k)/a^2 -> 2*(a^n + 1)/a^2    remainder is 2
            // if n is odd, after simplification
            //      2a(a^(n-1) + ... + a^((n-1)/2k + .. n)/a^2
            //      a^(n-1), a^((n-1)/2k are divisible by a^2   remainder is 2a*n
            // to maximize remainder, we must maximize 2an with 2an < a^2
            // 2an < a^2 -> 2n < a -> 2n <= a-1 -> n = (a-1)/2
            // n = (a-1)/2
            const ulong limit = 1000;
            ulong sum = 0;
            for (ulong a = 3; a <= limit; a++) {
                ulong maxN = (a - 1) / 2;
                sum += 2 * a * maxN;
            }
            return sum;
        }
        #endregion
        #region Problem 123
        public ulong Problem123() {
            // Same as 120 except a are prime numbers
            const ulong limit = 10000000000;
            const ulong sieveLimit = 1000000; // sqrt limit
            bool[] sieve = BuildSieve(sieveLimit);
            ulong pn = 3;
            ulong n = 2;
            while (true) {
                // If n = 1, remainder = 2*p1 = 2*2 which doesn't break the limit
                // If n is even, remainder = 2 which doesn't break the limit
                // So, we are looking for odd n
                if (0 != (n & 1)) { // remainder = 2an only if odd
                    ulong remainder = 2 * pn * n;
                    if (remainder >= limit)
                        return n;
                }
                // Next prime
                pn += 2;
                while (sieve[pn])
                    pn += 2;
                n++;
            }
            //return 0;
        }
        #endregion
        #region Problem 124
        private class _124_Radical {
            public ulong n, rad;
            public _124_Radical(ulong n, ulong rad) {
                this.n = n;
                this.rad = rad;
            }
            public static int Compare(_124_Radical a, _124_Radical b) {
                if (a.rad < b.rad)
                    return -1;
                else if (a.rad > b.rad)
                    return 1;
                else if (a.n < b.n)
                    return -1;
                else if (a.n > b.n)
                    return 1;
                return 0;
            }
            public override string ToString() {
                return n + "->" + rad;
            }
        }
        public ulong Problem124() {
            // Brute-force
            //ulong limit = 100000;
            //bool[] sieve = BuildSieve(limit);
            //_124_Radical[] radicals = new _124_Radical[limit+1];
            //radicals[0] = new _124_Radical(0,0);
            //radicals[1] = new _124_Radical(1, 1);
            //for (ulong n = 2; n <= limit; n++) {
            //    ulong rad = _127_Radical(sieve, n);
            //    radicals[n] = new _124_Radical(n,rad);
            //}
            //Array.Sort(radicals, _124_Radical.Compare);
            //return radicals[10000].n;

            // Build radical and prime on-the-go
            const ulong limit = 100000;
            _124_Radical[] radicals = new _124_Radical[limit + 1];
            radicals[0] = new _124_Radical(0, 0);
            radicals[1] = new _124_Radical(1, 1);
            for (ulong rad = 2; rad <= limit; rad++) {
                if (null != radicals[rad]) continue;
                for (ulong n = rad; n <= limit; n += rad) {
                    if (null == radicals[n])
                        radicals[n] = new _124_Radical(n, rad);
                    else
                        radicals[n].rad *= rad;
                }
            }
            Array.Sort(radicals, _124_Radical.Compare);
            return radicals[limit].n;
        }
        #endregion
        #region Problem 125
        public ulong Problem125() {
            // Sum square of every consecutive number from a to b and store the result if it's palindromic
            const ulong limit = 100000000;
            ulong sqrtLimit = (ulong)Math.Sqrt(limit);
            Dictionary<ulong, ulong> dict = new Dictionary<ulong, ulong>();
            for (ulong i = 1; i <= sqrtLimit; i++) {
                ulong sumSquare = i * i;
                for (ulong j = i + 1; j <= sqrtLimit; j++) { // sum consecutive number from i to limit
                    sumSquare += j * j;
                    if (sumSquare >= limit)
                        break; // No need to continue, further addition will also exceed limit
                    if (IsPalindromic(sumSquare, 10))
                        if (!dict.ContainsKey(sumSquare))
                            dict.Add(sumSquare, i);
                }
            }
            ulong sum = 0;
            foreach (KeyValuePair<ulong, ulong> kv in dict)
                sum += kv.Key;
            return sum;
        }
        #endregion
        #region Problem 127 TOO SLOW
        //http://oeis.org/wiki/Squarefree_kernel_function
        //http://en.wikipedia.org/wiki/Abc_conjecture
        private ulong _127_Radical(bool[] sieve, ulong n) {
            ulong sqrtN = (ulong)(Math.Sqrt(n) + 0.5);
            ulong p = 2;
            ulong rad = 1;
            while (true) {
                if (0 == (n % p))
                    rad *= p;
                while (0 == (n % p))
                    n /= p;
                if (n == 1)
                    break;
                // next prime
                p++;
                while (sieve[p])
                    p++;
            }
            return rad;
        }
        private ulong Problem127() {
            const ulong limit = 120000;
            ulong limitSieve = (ulong)(Math.Sqrt(limit * limit * limit) + 0.5);
            bool[] sieve = BuildSieve(limitSieve);
            ulong count = 0;
            ulong sum = 0;
            for (ulong a = 1; a < limit / 2; a++) {
                ulong radA = (a == 1) ? 1 : _127_Radical(sieve, a);
                for (ulong b = a + 1; b + a < limit; b++) {
                    ulong c = a + b;
                    if (!sieve[a] && !sieve[b] && !sieve[c]) // heuristic
                        continue;
                    if (1 != PGCD(a, b)) // by definition
                        continue;
                    if (1 != PGCD(a, c)) // by definition
                        continue;
                    if (1 != PGCD(b, c)) // by definition
                        continue;
                    ulong radB = _127_Radical(sieve, b);
                    ulong radC = _127_Radical(sieve, c);
                    ulong radProduct = radA * radB * radC; // property of radical function
                    if (radProduct < c) { // by definition
                        //Console.WriteLine(a + "," + b + "," + c + "->" + radProduct + " #=" + count + "  sum=" + sum);
                        count++;
                        sum += c;
                    }
                }
            }
            return sum;
        }
        #endregion
        #region Problem 128
        public ulong Problem128() {
            // Only the first and last of each layer must be checked
            // 3n(n-1)+2  first (line above 2, including 2)
            // potential neighbours giving prime
            //  down right: 3n(n+1)+1   diff: 6n-1
            //  up right: 3n(n+3)+7     diff: 12n+5
            //  up left: 3n(n+1)+3      diff: 6n+1
            // 3n(n+1)+1  last (line above 7, excluding 7)
            // potential neighbours giving prime
            //  down left: 3n(n-3)+8    diff: 12n-7
            //  up right: 3n(n+3)+6     diff: 6n+5
            //  up left: 3n(n-1)+2      diff: 6n-1
            const int count = 2000;
            List<ulong> list = new List<ulong>();
            list.Add(1);
            ulong n = 1;
            while (list.Count < count) {
                // first
                ulong first = 3 * n * (n - 1) + 2;
                ulong firstNeighbour1diff = 6 * n - 1;
                ulong firstNeighbour2diff = 12 * n + 5;
                ulong firstNeighbour3diff = 6 * n + 1;
                if (IsPrime(firstNeighbour1diff) && IsPrime(firstNeighbour2diff) && IsPrime(firstNeighbour3diff))
                    list.Add(first);

                // last
                if (n != 1) { // 7 is excluded
                    ulong last = 3 * n * (n + 1) + 1;
                    ulong lastNeighbour1diff = 12 * n - 7;
                    ulong lastNeighbour2diff = 6 * n + 5;
                    ulong lastNeighbour3diff = 6 * n - 1;
                    if (IsPrime(lastNeighbour1diff) && IsPrime(lastNeighbour2diff) && IsPrime(lastNeighbour3diff))
                        list.Add(last);
                }
                n++;
            }
            list.Sort();
            return list[count - 1];
        }
        #endregion
        #region Problem 129
        public ulong Problem129() {
            const ulong limit = 10;
            ulong n = limit + 1;
            while (true) {
                if (1 == PGCD(n, 10)) {
                    // Compute An
                    ulong An = 1;
                    ulong x = 1;
                    // Search repunit divisible by n
                    while (x != 0) {
                        x = (x * 10 + 1) % n;
                        An++;
                    }
                    if (An > limit)
                        break;
                }
                n += 2; // Only odd numbers
            }
            return n;
        }
        #endregion
        #region Problem 130
        public ulong Problem130() {
            List<ulong> numbers = new List<ulong>();
            numbers.AddRange(new ulong[] { 91, 259, 451, 481, 703 });
            ulong n = numbers[numbers.Count - 1] + 2;
            while (true) {
                // Don't consider prime
                if (!IsPrime(n) && 1 == PGCD(n, 10)) {
                    // Compute An
                    ulong An = 1;
                    ulong x = 1;
                    // Search repunit divisible by n
                    while (x != 0) {
                        x = (x * 10 + 1) % n;
                        An++;
                    }
                    // n-1 is composite and divisible by A(n)
                    if (0 == ((n - 1) % An))
                        numbers.Add(n);
                    if (25 == numbers.Count)
                        break;
                }
                n += 2; // Only odd numbers
            }
            ulong sum = 0;
            foreach (ulong number in numbers)
                sum += number;
            return sum;
        }
        #endregion
        #region Problem 131
        public ulong Problem131() {
            //http://en.wikipedia.org/wiki/Cuban_prime
            // cuban prime: 3*x^2 - 3*x + 1 = p
            const ulong limit = 1000000;
            bool[] sieve = BuildSieve(limit);
            ulong count = 0;
            bool fStop = false;
            ulong i = 3;
            while (!fStop) {
                if (!sieve[i]) {
                    // Compute x and reinject in equation, if equals to prime then it's a solution
                    ulong x = (ulong)((-3.0 + Math.Sqrt(9.0 - 12.0 * (1.0 - (double)i))) / 6.0);
                    ulong p = 3 * x * (x + 1) + 1;
                    if (p == i)
                        count++;
                }
                i += 2;
                if (i >= limit)
                    break;
                while (!fStop && sieve[i]) {
                    i += 2;
                    if (i >= limit)
                        fStop = true;
                }
            }
            return count;
        }
        #endregion
        #region Problem 132
        private ulong _132_Sub(ulong b, ulong n, ulong p) {
            if (1 == n) return 1;
            if (2 == n) return (1 + b) % p;
            ulong result = ((_132_Sub(b, n / 2, p) % p) * (1 + FastPowModulo_BeCareful(10, n / 2, p))) % p;
            if (1 == (n & 1))
                result = (result + FastPowModulo_BeCareful(10, n - 1, p)) % p;
            return result;
        }
        public ulong Problem132() {
            // R(n) = ( 10^n - 1 ) / 9   or R(n) * 9 + 1 = 10^n
            // R(n) = sum(i=1->n-1,10^i)
            // n = 4: 1 + 10^1 + 10^2 + 10^3 = ( 1 + 10^1 ) * ( 1 + 10^2 )
            // n = 5: 1 + 10^1 + 10^2 + 10^3 + 10^4 = ( 1 + 10^1 ) * ( 1 + 10^2 )^+ 10^4
            // n = 6: 1 + 10^1 + 10^2 + 10^3 + 10^4 + 10^5 = ( ( 1 + 10^1 ) + 10^2 ) * ( 1 + 10^3 )
            // ( a + b + c ) mod p = a mod p + b mod p + c mod p
            // R(n) mod p may be computed with a recursive function computing this sum modulo p
            // recurs( n, p )
            //  if n == 1, return 1
            //  if n == 2, return 1 + 10
            //  result = recurs( n/2, p ) mod p * ( 1 + 10^(n/2) mod p ) mod p
            //  if ( n odd )
            //      result += 10^(n-1) mod p
            //  return result

            ulong n = Pow(10, 9);
            ulong p = 3; // R(n) not divisible by 2
            List<ulong> factors = new List<ulong>();
            while (true) {
                if (IsPrime(p)) {
                    ulong remainder = _132_Sub(10, n, p);
                    if (0 == remainder)
                        factors.Add(p);
                }
                if (40 == factors.Count)
                    break;
                p += 2;
            }

            ulong sum = 0;
            foreach (ulong factor in factors)
                sum += factor;
            return sum;
        }
        #endregion
        #region Problem 134
        public ulong Problem134() {
            ulong[] digitsCount = { 0, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };
            const ulong limit = 1000000;
            bool[] sieve = BuildSieve(2 * limit);
            ulong p1 = 5; // first prime to consider
            ulong p2 = 7; // consecutive prime
            ulong sum = 0;
            while (true) {
                // Get number of digits of p1
                ulong pow10 = 10;
                for (ulong i = 1; i < (ulong)digitsCount.Length; i++) {
                    if (p1 <= digitsCount[i])
                        break;
                    pow10 *= 10;
                }

                // Brute-force
                //// Get smallest number multiple of index with last digits == previousIndex
                ////ulong count = 0;
                //ulong n = p2 * p1; // lower bound
                //while (true) {
                //    if (p1 == (n % pow10)) {
                //        // Found
                //        sum += n;
                //        //Console.WriteLine("p1:" + p1 + " p2:" + p2 + "  result:" + n + "  count:"+count);
                //        break;
                //    }
                //    n += p2; // Get next multiple
                //    //count++;
                //}

                // number must be a multiple of p2 and last digits must be equal to p1
                // number % 10^digits(p1) = p1
                // number / p2 must be integral
                // Solve equation p1*x = p2 (mod 10^digits(p1))
                long x, dummy;
                ExtendedPGCD((long)p2, (long)pow10, out x, out dummy);
                ulong result = 0;
                // number = p2 * ( ( p1 * x ) % 10^digits(p1) )
                if (x < 0)
                    result = p2 * (ulong)((long)pow10 + (((long)p1 * x) % (long)pow10));
                else
                    result = p2 * ((p1 * (ulong)x) % pow10);
                sum += result;

                // Get next prime
                p1 = p2;
                if (p1 >= limit)
                    break;
                while (sieve[++p2])
                    ;
            }
            return sum;
        }
        #endregion
        #region Problem 137
        public ulong Problem137() {
            // AF(x) = F1*x + F2*x^2 + F3*x^3 + ... + Fk*x^k ...
            // with Fk = Fk-1 + Fk-2 and F1 = 1 and F2 = 2
            // If AF(x) is a positive integer and x is a rational, AF(x) is called a golden nugget

            // F(x) generating function is x/(1-x-x^2)
            // x/(1-x-x^2) = n
            // n*x^2 + (n+1)*x - n = 0
            // delta = 5n^2+2n+1  must be a perfect square
            // brute-force to get first nuggets

            //// Brute-Force
            //List<ulong> nuggets = new List<ulong>();
            //for (ulong i = 1; i < 100000000; i++) {
            //    ulong delta = 5 * i * i + 2 * i + 1;
            //    if (IsPerfectSquare(delta)) {
            //        Console.WriteLine(i + "-->" + delta);
            //        nuggets.Add(i);
            //    }
            //}

            // 2, 15, 104, 714, 4895, 33552, 229970, 1576239, 10803704
            // nugget(k+1)-nugget(k) = F(4*k+3)
            // nugget(k) = F(2k)*F(2k+1)
            // nugget(k) = 7*nugget(k-1) - nugget(k-2) + 1

            ulong nugget_2 = 2;
            ulong nugget_1 = 15;
            int limit = 15;
            for (int i = 3; i <= limit; i++) {
                ulong nugget = 7 * nugget_1 - nugget_2 + 1;
                //Console.WriteLine(i + "-->" + nugget);
                nugget_2 = nugget_1;
                nugget_1 = nugget;
            }

            return nugget_1;
        }
        #endregion
        #region Problem 138
        public ulong Problem138() {
            //// Brute-force
            //// h=b-1 or h=b+1
            //// h^2 = L^2 - (b/2)^2
            //// (b+/-1)^2 + (b/2)^2 - L^2 = 0
            //// 5/4*b^2 +/- 2*b + 1 - L^2 = 0
            //// delta = 4 - 4*5/4*(1-L^2) = 4 - 5*(1-L^2)
            //// b = ( -/+ b - sqrt(delta) ) / (5/2)
            //// if delta is a perfect square, h = b +/- 1
            //// b must be even
            //ulong limit = 12;
            //ulong sum = 0;
            //ulong side = 5;
            //ulong count = 0;
            //List<ulong> list = new List<ulong>();
            //while (true) {
            //    ulong toTest = 4 - 5 * (1 - side * side);
            //    ulong sqrtToTest = (ulong)(Math.Sqrt(toTest) + 0.5);
            //    if (sqrtToTest * sqrtToTest == toTest) {
            //        list.Add(side);
            //        sum += side;
            //        if ( 0 == ( side & 1 ) )
            //            side++; // Must be odd
            //        count++;
            //        if (limit == count)
            //            break;
            //    }
            //    side += 2;
            //}
            //return sum;

            // First values: 17, 305, 5473, 98209, 1762289, 31622993
            // f(n)/f(n-1) = 17.94...
            // 17*f(n) + f(n-1) -> incorrect
            // 18*f(n) - f(n-1) -> correct
            // f(0) = 1
            // f(1) = 17
            // f(n) = 18*f(n-1) - f(n-2)
            const ulong limit = 12;
            ulong count = 1;
            ulong Fn_2 = 1;
            ulong Fn_1 = 17;
            ulong sum = 17;
            while (count < limit) {
                ulong Fn = 18 * Fn_1 - Fn_2;
                sum += Fn;
                Fn_2 = Fn_1;
                Fn_1 = Fn;
                count++;
            }
            return sum;
        }
        #endregion
        #region Problem 141
        public ulong Problem141() {
            //long limit = 1000000; // sqrt(10^12)
            //ulong sum = 0;
            //for (long i = 3; i <= limit; i++) {
            //    long n = i * i;
            //    for (long d = 2; d <= i; d++) {
            //        long q, r;
            //        q = Math.DivRem(n, d, out r);
            //        // d/r = q/d -> d^2 = q*r
            //        // consecutive ==> q/r = (q/d)^2 -> d^2 = q*r
            //        if (d * d == q * r) {
            //            sum += (ulong)n;
            //            // interesting property
            //            // d^2 = q*r   with r = n-q*d
            //            // d^2 = q*(n-q*d)
            //            // d*q^2 - n*q + d^2 = 0
            //            // delta = n^2 - 4*d*d^2 = n^2 - 4*d^3   from already found results we see
            //            // n - sqrt( delta ) = 2*r
            //            // with delta a perfect square
            //            Console.WriteLine(i + "^2 = " + d + "*" + q + "+" + r + " = " + n + "   sum=" + sum);
            //            break;
            //        }
            //    }
            //}
            //return sum;

            // n = d * q + r
            // q/d = d/r  and  q/r = (d/r)^2
            // { r, d, q } = { r, r*a/b, r*a^2/b^2 } with PGCD(a,b) == 1
            // q is integral if r is a multiple of b^2
            // r = b^2 * c
            // { r, d, q } = { b^2, a*b*c, a^2*c }
            // n = b*c*(b+a^3*c)  n must be a perfect square and lower than 10^21
            Dictionary<ulong, int> dict = new Dictionary<ulong, int>();
            const ulong limit = 1000000000000;
            for (ulong a = 2; a < 200/*trial-error*/; a++)
                for (ulong b = 1; b < a; b++) {
                    ulong pgcd = PGCD(a, b);
                    if (pgcd > 1)
                        continue;
                    for (ulong c = 1; ; c++) {
                        ulong m2 = b * c * (b + c * a * a * a);
                        if (m2 >= limit)
                            break;
                        if (IsPerfectSquare(m2)) {
                            if (dict.ContainsKey(m2))
                                dict[m2]++;
                            else
                                dict.Add(m2, 1);
                        }
                    }
                }
            ulong sum = 0;
            foreach (KeyValuePair<ulong, int> kv in dict) {
                sum += kv.Key;
                //Console.WriteLine(kv.Key + " #=" + kv.Value);
            }
            return sum;
        }
        #endregion
        #region Problem 142
        public ulong Problem142() {
            // x+y = a^2
            // x-y = b^2
            // x+z = c^2
            // x-z = d^2
            // y+z = e^2
            // y-z = f^2
            //
            // a^2 + b^2 = c^2 + d^2
            // c^2 - b^2 = e^2
            // a^2 - c^2 = f^2
            //
            // x = (a^2+b^2)/2
            // y = (a^2-b^2)/2
            // z = (a^2+b^2)/2 - c^2
            //
            // so, with a, b, c we can find d, e, f and x, y, z
            // a > c > b and must have the same parity
            bool fSolved = false;
            ulong result = 0;
            ulong a = 1;
            while (!fSolved) {
                ulong a2 = a * a;
                for (ulong c = a & 1; c < a && !fSolved; c += 2) {
                    if (0 == c) continue;
                    ulong c2 = c * c;
                    ulong f2 = a2 - c2;
                    if (!IsSquare(f2)) continue;
                    for (ulong b = c & 1; b < c && !fSolved; b += 2) {
                        if (0 == b) continue;
                        ulong b2 = b * b;
                        ulong e2 = c2 - b2;
                        if (!IsSquare(e2)) continue;
                        ulong d2 = a2 + b2 - c2;
                        if (!IsSquare(d2)) continue;
                        // Found
                        fSolved = true;
                        ulong x = (a2 + b2) / 2;
                        ulong y = (a2 - b2) / 2;
                        ulong z = x - c2;
                        result = x + y + z;
                    }
                }
                a++;
            }
            return result;

            //long a2, b2, c2, d2, e2, f2;
            //bool solved = false;

            //for (long a = 10; !solved; a++) {
            //    a2 = a * a;
            //    for (long c = 5 + (0 & a); c < a && !solved; c += 2) {
            //        c2 = c * c;
            //        f2 = a2 - c2;
            //        if (f2 < 1 || !IsSquare((ulong)f2))
            //            continue;
            //        for (long d = 2 + (1 & c); d < c; d += 2) {
            //            d2 = d * d;
            //            e2 = a2 - d2;
            //            if (e2 < 1 || !IsSquare((ulong)e2))
            //                continue;
            //            b2 = c2 - e2;
            //            if (b2 > 0 && IsSquare((ulong)b2)) {
            //                long x = (a2 + b2) / 2;
            //                long y = (e2 + f2) / 2;
            //                long z = (c2 - d2) / 2;
            //                solved = true;
            //                Console.WriteLine("x= " + x.ToString() +
            //                     " y = " + y.ToString() + " z = " + z.ToString()
            //                     + " sum = " + (z + y + x).ToString());
            //                break;
            //            }
            //        }
            //    }
            //}
            //return 0;
        }
        #endregion
        #region Problem 144
        public ulong Problem144() {
            // Entering point
            double oldX = 0;
            double oldY = 10.1;
            // First reflection point
            double newX = 1.4;
            double newY = -9.6;
            ulong count = 0;
            while (!(Math.Abs(newX) <= 0.01 && newY > 0)) {
                count++;
                // Line from old to new
                double m = (oldY - newY) / (oldX - newX);
                double n = oldY - m * oldX;
                // Normal at intersection with ellipse
                double normalM = newY / (4 * newX); // slope, given in problem
                double normalN = newY - normalM * newX;
                // Reflected line
                double tan_alpha = (m - normalM) / (1 + m * normalM);
                double reflectM = (normalM - tan_alpha) / (1 + normalM * tan_alpha);
                double reflectN = newY - reflectM * newX;
                // old = new
                oldX = newX;
                oldY = newY;
                // Compute new intersection
                double b = (2 * reflectM * reflectN) / (4 + reflectM * reflectM);
                newX = -b - oldX;
                newY = reflectM * newX + reflectN;
            }
            return count;
        }
        #endregion
        #region Problem 145
        public ulong Problem145() {
            // Brute-force
            //ulong[] digitsCount = { 0, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };
            //ulong limit = 1000000000;
            //ulong count = 0;
            //for (ulong n = 12; n <= limit; n++) {
            //    if (n % 1000000 == 0)
            //        Console.WriteLine(n);
            //    if (0 == (n % 10)) // no leading 0
            //        continue;
            //    ulong pow10 = 1;
            //    for (ulong i = 1; i < (ulong)digitsCount.Length; i++) {
            //        if (n <= digitsCount[i])
            //            break;
            //        pow10 *= 10;
            //    }
            //    bool fOk = true;
            //    ulong carry = 0;
            //    ulong number = n;
            //    while (number > 0) {
            //        ulong digitNumber = (n / pow10) % 10;
            //        ulong digitReverse = number % 10;
            //        ulong sum = digitNumber + digitReverse + carry;
            //        if (sum >= 10)
            //            carry = 1;
            //        else
            //            carry = 0;
            //        if (0 == (sum & 1)) {
            //            fOk = false;
            //            break;
            //        }
            //        number /= 10;
            //        pow10 /= 10;
            //    }
            //    if (fOk)
            //        count++;
            //}
            //return count;

            // Brute-force
            const ulong limit = 1000000000;
            ulong[] digits = new ulong[10];
            for (int i = 0; i < digits.Length; i++)
                digits[i] = 0;
            digits[0] = 1;
            ulong length = 1; // Length in digits
            ulong count = 0;
            for (ulong n = 1; n < limit; n++) {
                ulong i = 0;
                if (digits[0] > 0) { // No trailing zeroes
                    ulong carry = 0; // Carry
                    for (i = 0; i < length; ++i) {
                        ulong sum = digits[i] + digits[length - 1 - i] + carry; // Digits of sum
                        if (0 == (sum & 1))
                            break; // Want odd ones
                        carry = (sum >= 10) ? (ulong)1 : (ulong)0; // New carry
                    }
                    if (i == length)
                        count++; // Got one
                }
                // Increment
                for (i = 0; digits[i] == 9; ++i)
                    digits[i] = 0;
                if (i == length) {
                    length++;
                    digits[i] = 1;
                }
                else
                    digits[i]++;
            }
            return count;

            // Trailing digit cannot be 0
            // 1 digit: 0 solutions
            // 2 digits: ab: a+b must be odd and < 10 ==> 20 solutions
            // 3 digits: abc: a+c must be odd and > 10, 2b must be < 10 ==> 20 (ac) * 5 (b) solutions
            // 4 digits: abcd: a+d must be odd and < 10, b+c must be odd and < 10 => 20 (ad) * 30 (bc) solutions
            // 5 digits: 0 solutions
            // 6 digits: abcdef: a+f, b+e, c+d must be odd and < 10 => 20 (af) * 30 (be) * 30 (cd) solutions
            // 7 digits: abcdefg: a+g must be odd and > 10, b+f even and > 10, c+e even and > 10, 2d must be < 10 => 20 (ag) * 25 (bf) * 20 (ce) * 5 (d) solutions
            // 8 digits: see 2, 4 and 6 ==> 20*30*30*30 solutions
            // 9 digits: 0 solutions
            // 10 digits: see 2, 4 and 6 ==> 20*30*30*30*30 solutions
            // 2n digits: 20*30^(n-1)
            // 4n+1 digits: no solutions
            // 4n+3 digits: 5*20*(25*20)^n
            //ulong limit = 1000000000;
            //ulong sum = 0;
            //for (ulong i = 1; i <= 9; i++) {
            //    if (0 == (i & 1))
            //        sum += 20 * PowModulo(30, i / 2 - 1, limit);
            //    else if (3 == (i % 4))
            //        sum += 5 * 20 * PowModulo(25 * 20, i / 4, limit);
            //}
            //return sum;
        }
        #endregion
        #region Problem 146
        public ulong Problem146() {
            //// 2 hours to complete
            //// 10, 315410, 927070, 2525870, 8146100, 16755190, 39313460, 97387280, 119571820, 121288430, 130116970, 139985660
            //// n^2+1, n^2+3, n^2+7, n^2+9, n^2+13, n^2+27 consecutive primes
            //const ulong limit = 150000000;
            //ulong sum = 0;
            //for (ulong i = 10; j <= limit; j+=10) {
            //    if (0 == (i % 3))
            //        continue;
            //    if ((i + 4) % 7 > 1) // n % 7 must be 3 or 4
            //        continue;
            //    ulong n = (i * i);
            //    if (0 == (n % 3) || 0 == (n % 7) || 0 == (n % 13))
            //        continue;
            //    if (IsPrime(n + 13) && IsPrime(n + 3) && IsPrime(n + 7) && IsPrime(n + 9) && IsPrime(n + 1) && IsPrime(n + 27)
            //        && !IsPrime(n + 19) && !IsPrime(n + 21)) {
            //        Console.WriteLine(i+"-->"+n);
            //        sum += i;
            //    }
            //}
            //return 0;

            const ulong limit = 150000000;
            List<ulong> list = new List<ulong>();
            //
            for (ulong n = 10; n <= limit; n += 10) {
                if (0 == (n % 3)) continue;
                if ((n + 4) % 7 > 1) continue; // n % 7 must be 3 or 4
                ulong n2 = n * n;
                if (0 == (n2 % 3) || 0 == (n2 % 7) || 0 == (n2 % 13)) continue;
                // Prime test
                ulong p = 11;
                while (true) {
                    // Check prime conditions
                    if ((n2 + 27) % p <= 27) {
                        if (0 == (n2 + 1) % p) break;
                        if (0 == (n2 + 3) % p) break;
                        if (0 == (n2 + 7) % p) break;
                        if (0 == (n2 + 9) % p) break;
                        if (0 == (n2 + 13) % p) break;
                        if (0 == (n2 + 27) % p) break;
                    }
                    // Next prime
                    p += 2;
                    if (0 == (p % 3)) p += 2;
                    if (p > n + 1) { // every prime under sqrt(n2) has been checked
                        // Found a candidate
                        // Check 'consecutivness'
                        if (IsPrime(n2 + 19)) break;
                        if (IsPrime(n2 + 21)) break;
                        list.Add(n);
                        break;
                    }
                }
            }
            //
            ulong sum = 0;
            foreach (ulong item in list)
                sum += item;
            return sum;
        }
        #endregion
        #region Problem 148
        private string _148_ConvertToBase(ulong number, ulong b) {
            StringBuilder sb = new StringBuilder();
            while (number > 0) {
                ulong digit = number % b;
                char c = (char)(digit + 48);
                sb.Insert(0, c);
                number /= b;
            }
            return sb.ToString();
        }
        private ulong _148_SumUpTo(string digits, ulong p) {
            if (0 == digits.Length)
                return 1;
            ulong k = (ulong)(digits.Length - 1);
            ulong n = (ulong)(digits[0] - 48);
            ulong subResult = _148_SumUpTo(digits.Substring(1, digits.Length - 1), p);
            ulong result = ((n * (n + 1)) / 2) * Pow((p * (p + 1)) / 2, k) + (n + 1) * subResult;
            return result;
        }
        public ulong Problem148() {
            // 8th line: 1, 7, 21, 35, 35, 21, 7, 1 -> every numbers except 1 is divisible by 7
            // 9th line: 1, 8, 28, 56, 70, 56, 28, 8, 1 -> 28, 56 and 70 are divisible by 7
            // 10th line: 1, 9, 36, 84, 126, 126, 84, 36, 9, 1 -> 84 and 126 are divisible by 7
            // 11th line: 1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1 -> 210 and 252 are divisible by 7
            // 12th line: 1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1 -> 462 is divisible by 7
            // 13th line: 1, 12, 66, 220, 495, 792, 924, 798, 495, 220, 66, 12, 1 -> 792 is divisible by 7
            // this pattern is a reverse triangle with a base of 6 -> 21 elements are divisible by 7 [6*(6+1)/2]
            // pattern is a Serpinski triangle

            // It is possible to show that if p is prime, choose(m, n) is not divisible by p if and only if the addition n + (m-n) when written in base p has no carries. This means that the number of entries in the mth row of Pascal's triangle that are not divisible by p is equal to the product over all digits d of m written in base p of 1+d.
            // For example...
            // 10 base 2 is 1001, which means that the number of odd entries in the 10th row of pascal triangle is 2*1*1*2=4.
            // 10 base 5 is 20 --> number of entries in 10th row not divisible by 5 is 3*1=3. 

            // for row n (starting with 0), if we write n in base p
            // n = sum(i=0->k, a(i) * p^i )   k number of digits of n in base p, a(i) = i-th digit of n in base p
            // then, the number of entries in that row is (a(0)+1) * (a(1)+1) * (a(2)+1) ...  * (a(k)+1)
            ulong limit = Pow(10, 9);
            ulong p = 7;
            string digits = _148_ConvertToBase(limit - 1, p);
            ulong result = _148_SumUpTo(digits, p);
            return result;
        }
        #endregion
        #region Problem 149
        public ulong Problem149() {
            // |laggedFibonacci| < 1500000
            const long side = 2000;
            // Generate lagged fibonacci
            long[] laggedFibonacci = new long[side * side + 1];
            for (long i = 1; i <= 55; i++)
                laggedFibonacci[i] = ((100003 - 200003 * i + 300007 * i * i * i) % 1000000) - 500000;
            for (long i = 56; i <= side * side; i++)
                laggedFibonacci[i] = ((laggedFibonacci[i - 24] + laggedFibonacci[i - 55] + 1000000) % 1000000) - 500000;
            //// Create grid
            //long[,] grid = new long[side, side];
            //for (long i = 0; i < side; i++)
            //    for (long j = 0; j < side; j++)
            //        grid[i, j] = laggedFibonacci[i * side + j + 1];
            // Get best sum
            long best = 0;
            for (long i = 0; i < side; i++) {
                long current1 = 0;
                long current2 = 0;
                for (long j = 0; j < side; j++) {
                    if (current1 < 0) current1 = 0;
                    if (current2 < 0) current2 = 0;
                    //current1 += grid[i, j];
                    current1 += laggedFibonacci[i * side + j + 1];
                    //current2 += grid[j, i];
                    current2 += laggedFibonacci[j * side + i + 1];
                    if (current1 > best) best = current1;
                    if (current2 > best) best = current2;
                }
            }
            for (long i = -2000; i <= 2000; i++) {
                long current = 0;
                for (long j = 0; j < 2000; j++) {
                    if (j + i >= 0 && j + i < 2000) {
                        if (current < 0) current = 0;
                        //current += grid[j, i + j];
                        current += laggedFibonacci[j * side + (j + i) + 1];
                        if (current > best) best = current;
                    }
                }
            }
            for (long i = 0; i < 4000; i++) {
                long current = 0;
                for (long j = 0; j < 2000; j++) {
                    if (j - i >= 0 && j - i < 2000) {
                        if (current < 0) current = 0;
                        //current += grid[j, j - i];
                        current += laggedFibonacci[j * side + (j - i) + 1];
                        if (current > best) best = current;
                    }
                }
            }

            return (ulong)best;
        }
        #endregion
        #region Problem 150
        public long Problem150() {
            //    0
            //   1 2
            //  3 4 5
            // 6 7 8 9
            // 0: 0, 0 -> 0+0 -> 0+0
            // 1: 0, 1 -> 0+(1+0)
            // 2: 1, 1 -> 1+(1+0)
            // 3: 0, 2 -> 0+(2+1+0)
            // 4: 1, 2 -> 1+(2+1+0)
            // 5: 2, 2 -> 2+(2+1+0)
            // 6: 0, 3 -> 0+(3+2+1+0)
            // 7: 1, 3 -> 1+(3+2+1+0)
            // 8: 2, 3 -> 2+(3+2+1+0)
            // 9: 3, 3 -> 3+(3+2+1+0)
            // col, row -> col + row*(row+1)/2
            // triangle starting at i, j
            // next line: i,j+1 -> i+1,j+1
            // next line: i,j+2 -> i+2,j+2
            // next line: i,j+3 -> i+3,j+3

            long power19 = (long)Pow(2, 19);
            long power20 = power19 * 2;
            int height = 1000;
            int size = height * (height + 1) / 2;
            long[] array = new long[size];
            long t = 0;
            for (int i = 0; i < size; i++) {
                t = (615949 * t + 797807) & (power20 - 1); // modulo 2^20
                array[i] = t - power19;
                //array[i] = i;
            }
            //int height = 6;
            //long[] array = { 
            //    15, 
            //    -14, -7, 
            //    20, -13, -5, 
            //    -3, 8, 23, -26, 
            //    1, -4, -5, -18, 5, 
            //    -16, 31, 2, 9, 28, 3 };
            long[,] sums = new long[1, 1];
            sums[0, 0] = array[0];
            long best = sums[0, 0];
            for (int i = 1; i < height; i++) {
                long[,] newSums = new long[i + 1, i + 1];
                //Console.WriteLine("Line:" + i);
                int indexShift = i * (i + 1) / 2;
                for (int j = 0; j <= i; j++) {
                    int index = indexShift + j;
                    //Console.WriteLine(j + "," + i + "->" + index + " = " + array[index]);
                    //Console.WriteLine("++++++++++++++++");
                    long sum = 0;
                    // TOO SLOW
                    //for (int k = i; k < height; k++) {
                    //    //Console.WriteLine("line:" + k);
                    //    int subIndexShift = k * (k + 1) / 2;
                    //    for (int l = 0; l <= k-i; l++) {
                    //        int subIndex = subIndexShift + l + j;
                    //        sum += array[subIndex];
                    //        //Console.WriteLine(l + "," + k + "->" + index + " = " + array[subIndex]);
                    //    }
                    //    //Console.WriteLine("Sum: " + sum);
                    //    if (sum < best) {
                    //        best = sum;
                    //        //Console.WriteLine("Best: " + best);
                    //    }
                    //}
                    // Keep previously computed sum
                    for (int k = j; k <= i; k++) {
                        int subIndex = indexShift + k;
                        sum += array[subIndex];
                        if (j == k)
                            newSums[j, k] = sum;
                        else
                            newSums[j, k] = sum + sums[j, k - 1];
                        if (newSums[j, k] < best)
                            best = newSums[j, k];
                    }
                    //Console.WriteLine("----------------");
                }
                sums = newSums;
            }
            return best;
        }
        #endregion
        #region Problem 151
        private double _151_Cut(ulong a2, ulong a3, ulong a4, ulong a5) {
            ulong sheets = a2 + a3 + a4 + a5;
            if (0 == sheets)
                return 0;
            double singles = (1 == sheets && a5 == 0) ? 1 : 0;
            if (a2 > 0)
                singles += (double)a2 * _151_Cut(a2 - 1, a3 + 1, a4 + 1, a5 + 1);
            if (a3 > 0)
                singles += (double)a3 * _151_Cut(a2, a3 - 1, a4 + 1, a5 + 1);
            if (a4 > 0)
                singles += (double)a4 * _151_Cut(a2, a3, a4 - 1, a5 + 1);
            if (a5 > 0)
                singles += (double)a5 * _151_Cut(a2, a3, a4, a5 - 1);
            return singles / (double)sheets;

        }
        public string Problem151() {
            double result = _151_Cut(1, 1, 1, 1);
            return Math.Round(result, 6).ToString().Replace(',', '.');
        }
        #endregion
        #region Problem 153 TOO SLOW
        private ulong Problem153() {
            // http://oeis.org/A132994

            // n/(a+bi) = na/(a^2+b^2) - i * nb/(a^2+b^2)
            // na and nb divisible by a^2+b^2
            // na/(a^2+b^2) > 0  with n positive integer, a is also positive integer and b is integer
            // b = 0, a = 1 -> 1 solution
            // b = 0, a = n -> 1 solution
            // sum(b) = 0 because if a,b is a solution then a,-b is also a solution
            const ulong limit = 100000;
            ulong sum = 0;
            for (ulong n = 1; n <= limit; n++) {
                //Console.WriteLine(n);
                // b = 0, a = n
                //Console.Write(n + "," + 0 + " | ");
                sum += n; // n,0
                for (ulong a = 1; a <= n / 2; a++) {
                    ulong upperBound = (ulong)(Math.Sqrt(n * n - a * a) + 0.5);
                    // b = 0
                    if (0 == (n % a)) {
                        //Console.Write(a + "," + 0 + " | ");
                        sum += a; // a,0
                    }
                    // b > 0
                    for (ulong b = 1; b <= upperBound; b++) {
                        ulong divisor = a * a + b * b;
                        if (0 == ((n * a) % divisor) && 0 == ((n * b) % divisor)) {
                            //Console.Write(a + "," + b + " | ");
                            //Console.Write(a + ",-" + b + " | ");
                            sum += 2 * a; // a,b and a,-b
                        }
                    }
                }
                //Console.WriteLine();
            }
            return sum;
        }
        #endregion
        #region Problem 155
        public ulong Problem155() {
            //http://oeis.org/A051389
            ulong[] a051389 = { 1, 2, 4, 8, 20, 42, 102, 250, 610, 1486, 3710, 9228, 23050, 57718, 145288, 365820, 922194, 2327914 };
            ulong sum = 0;
            foreach (ulong n in a051389)
                sum += n;
            return sum;
        }
        #endregion
        #region Problem 160 UNDER CONSTRUCTION
        private ulong Problem160() {
            //http://mathcentral.uregina.ca/QQ/database/QQ.09.07/s/mukesh1.html
            //http://www.cat4mba.com/forum/number-system/last-non-zero-digit

            // Brute-force
            const ulong numDigits = 5;
            const ulong limit = 1000000000000;
            ulong lastDigits = (ulong)Math.Pow(10, numDigits);
            ulong a2 = 0, a5 = 0;
            ulong result = 1;
            using (System.IO.StreamWriter sw = new System.IO.StreamWriter(@"..\..\..\output.txt")) {

                for (ulong i = 1; i <= limit; i++) {
                    ulong j = i;
                    //divide i by 2 and 5
                    while (j % 2 == 0) {
                        j /= 2;
                        a2++;
                    }
                    while (j % 5 == 0) {
                        j /= 5;
                        a5++;
                    }
                    result = (result * (j % lastDigits)) % lastDigits;
                    if (i == 9 || i == 10 || i == 20 || i == 100 /* || 0 == ( i % (limit/100))*/) {
                        //9-->36288  a2=7  a5=1  result=567
                        //10-->36288  a2=8  a5=2  result=567
                        //20-->17664  a2=18  a5=4  result=55421
                        //1000000000->38144
                        //10000000000-->46112  a2=9999999989  a5=2499999997  result=64047
                        //20000000000-->67808  a2=19999999989  a5=4999999997  result=18223
                        //30000000000-->60896  a2=29999999985  a5=7499999996  result=93133
                        //40000000000-->16576  a2=39999999989  a5=9999999997  result=2831
                        //50000000000-->46112  a2=49999999985  a5=12499999997  result=15377
                        //60000000000-->59904  a2=59999999985  a5=14999999996  result=61517
                        //70000000000-->94528  a2=69999999988  a5=17499999997  result=57711
                        //80000000000-->9376  a2=79999999989  a5=19999999997  result=59631
                        //90000000000-->94208  a2=89999999987  a5=22499999996  result=87621
                        //100000000000-->67808  a2=99999999985  a5=24999999997  result=82193
                        //110000000000-->58816  a2=109999999987  a5=27499999997  result=61959
                        //120000000000-->15008  a2=119999999985  a5=29999999996  result=14509
                        //130000000000-->85664  a2=129999999987  a5=32499999997  result=91811
                        //140000000000-->9664  a2=139999999988  a5=34999999996  result=70859
                        //144112947008-->[[15776 wrong because process stopped in the middle of 2^b]]  a2=144112946992  a5=36028236745  result=65613
                        ulong dump = result;
                        ulong b = a2 - a5;
                        //for (ulong k = 1; k <= b; k++)
                        //    dump = (dump * 2) % lastDigits;
                        ulong multiplier = PowModulo(2, b, lastDigits);
                        dump = (dump * multiplier) % lastDigits;

                        sw.WriteLine(i + "-->" + dump + "  a2=" + a2 + "  a5=" + a5 + "  result=" + result);
                        sw.Flush();
                    }
                }
                // result = result * 2^a2 * 5^a5
                // number of trailing zeroes = a5
                // 2^a5 * 5^a5 = 10^number of trailing zeroes
                // so we have divided too much while removing trailing zeroes, 2^(a2-a5) gives this factor
                // result without trailing zeroes = result * 2^(a2-a5)
                ulong a = a2 - a5;
                ulong pow2 = PowModulo( 2, a, lastDigits );
                result = (result * pow2) % lastDigits;
                //for (ulong i = 1; i <= a; i++)
                //    result = (result * 2) % lastDigits;
                sw.WriteLine(limit+"-->"+result);
            }
            return result;

            //using (System.IO.StreamWriter sw = new System.IO.StreamWriter(@"..\..\..\output.txt")) {
            //    const ulong numDigits = 1;
            //    //const ulong limit = 2000;
            //    ulong lastDigits = (ulong)Math.Pow(10, numDigits);
            //    for (ulong k = 2; k <= 2; k++) {
            //        ulong a5 = 0;
            //        ulong a2 = 0;
            //        ulong result = 1;
            //        ulong start = (k-1)*lastDigits+1;
            //        ulong end = k*lastDigits;
            //        sw.WriteLine("FROM:" + start + " TO:" + end);
            //        for (ulong i = start; i <= end; i++) {
            //            // Divide i by 2 and 5
            //            ulong j = i;
            //            while (j % 2 == 0) {
            //                j /= 2;
            //                a2++;
            //            }
            //            while (j % 5 == 0) {
            //                j /= 5;
            //                a5++;
            //            }
            //            result = (result * (j % lastDigits)) % lastDigits;
            //            sw.WriteLine(i.ToString().PadLeft(4) + ") " + j.ToString().PadLeft(4) + "  " + result);
            //        }
            //        // a5 gives the number of trailing 0
            //        ulong a = a2 - a5;
            //        for (ulong i = 1; i <= a; i++)
            //            result = (result * 2) % lastDigits;
            //        sw.WriteLine("RESULT:" + result);
            //    }
            //}
            //return 0;
        }
        #endregion
        #region Problem 162
        public string Problem162() {
            // Since the first digit is non zero the total possibilities without consideration for the constraints is 15 x 16(n-1).
            // Then remove those with no {0, 1, A}. But we need to add back in those that have no 1 or 0, no 1 or A, no 0 or A.
            // Then remove the duplicates that, again, have no {0, 1, A}
            // 15*16^(n-1) - 2*14*15^(n-1) - 15*15^(n-1) + 13*14^(k-1) + 2*14*14^(k-1) - 13*13^(k-1)
            ulong sum = 0;
            for (ulong i = 3; i <= 16; i++)
                sum += 15 * Pow(16, i - 1) - (2 * 14 + 15) * Pow(15, i - 1) + (13 + 2 * 14) * Pow(14, i - 1) - 13 * Pow(13, i - 1);
            return String.Format("{0:X}", sum);
        }
        #endregion
        #region Problem 163
        public ulong Problem163() {
            //http://www.math.uni-bielefeld.de/~sillke/SEQUENCES/grid-triangles
            ulong n = 36;
            ulong a60 = n * (n + 2) * (2 * n + 1) / 8 + 2 * ((3 * n * n - 1) * n / 6);
            ulong a90 = 6 * (n * (n + 1) * (n + 2) / 6 + (((2 * n + 5) * n + 2) * n) / 8 + (((2 * n + 3) * n - 3) * n) / 18 + ((2 * n + 3) * n - 3) * n / 10);
            ulong a120 = 3 * (((22 * n + 45) * n - 4) * n / 48);
            return a60 + a90 + a120;
        }
        #endregion
        #region Problem 164
        private ulong _164_GetCount(ulong limit, ulong[, ,] count, ulong d1, ulong d2, ulong remainDigits) {
            if (remainDigits == 0)
                return 1;
            else {
                if (count[d1, d2, remainDigits] == 0)
                    for (ulong i = 0; i <= limit - (d1 + d2); i++)
                        count[d1, d2, remainDigits] += _164_GetCount(limit, count, d2, i, remainDigits - 1);
                return count[d1, d2, remainDigits];
            }
        }
        public ulong Problem164() {
            const ulong limit = 9;
            const ulong numDigits = 20;
            ulong[, ,] count = new ulong[10, 10, numDigits];
            ulong result = 0;
            for (ulong i = 1; i <= 9; i++)
                result += _164_GetCount(limit, count, 0, i, numDigits - 1);
            return result;
        }
        #endregion
        #region Problem 166
        public ulong Problem166() {
            ulong count = 0;
            for (ulong a1 = 0; a1 < 10; a1++)
                for (ulong a2 = 0; a2 < 10; a2++)
                    for (ulong a3 = 0; a3 < 10; a3++)
                        for (ulong a4 = 0; a4 < 10; a4++)
                            for (ulong a5 = 0; a5 < 10; a5++)
                                for (ulong a6 = 0; a6 < 10; a6++)
                                    for (ulong a7 = 0; a7 < 10; a7++)
                                        for (ulong a9 = 0; a9 < 10; a9++)
                                            for (ulong a11 = 0; a11 < 10; a11++) {
                                                ulong d = a1 + a2 + a3 + a4;
                                                ulong a8 = d - a5 - a6 - a7;
                                                if (a8 >= 0 && a8 < 10) {
                                                    ulong a13 = d - a1 - a5 - a9;
                                                    if (a13 >= 0 && a13 < 10) {
                                                        ulong a10 = d - a4 - a7 - a13;
                                                        if (a10 >= 0 && a10 < 10)
                                                            if (d == a4 + a7 + a10 + a13) {
                                                                ulong a12 = d - a9 - a10 - a11;
                                                                if (a12 >= 0 && a12 < 10) {
                                                                    ulong a14 = d - a2 - a6 - a10;
                                                                    if (a14 >= 0 && a14 < 10) {
                                                                        ulong a15 = d - a3 - a7 - a11;
                                                                        if (a15 >= 0 && a15 < 10) {
                                                                            ulong a16 = d - a4 - a8 - a12;
                                                                            if (a16 >= 0 && a16 < 10
                                                                                && d == a13 + a14 + a15 + a16
                                                                                && d == a1 + a6 + a11 + a16)
                                                                                count++;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                    }
                                                }
                                            }
            return count;
        }
        #endregion
        #region Problem 168
        public ulong Problem168() {
            // Brute-force
            //ulong sum = 0;
            //ulong pow10 = 1;
            //for (ulong digitsCount = 2; digitsCount <= 8; digitsCount++) {
            //    pow10 *= 10;
            //    ulong nextPow10 = pow10 * 10;
            //    for (ulong n = pow10; n < nextPow10; n++) {
            //        ulong lastDigit = n % 10;
            //        ulong firstDigits = n / 10;
            //        ulong firstDigit = firstDigits % 10;
            //        if (0 == lastDigit) continue;
            //        if (lastDigit < firstDigit) continue;
            //        ulong m = firstDigits + (lastDigit * pow10);
            //        ulong remainder = m % n;
            //        if (0 == remainder) {
            //            ulong quotient = m / n;
            //            sum = (sum + n) % 100000;
            //            Console.WriteLine(n + "*" + quotient + " = " + m + "   --> "+sum);
            //        }
            //    }
            //}

            //let n = AB  with B the last digit and A the first digits of number
            //let m and k be such as   
            //     m * ( 10*A + B ) = B * 10^k + A  with k = number of digits of A and m in [1,9]
            //A = B * ( 10^k - m ) / ( 10*m - 1 )
            //N = A * 10 + B
            // If  B * ( 10^k - m ) % ( 10*m - 1 ) == 0  and  N > 10^k  then  we have found a solution
            BigInt sum = 0;
            for (long m = 1; m <= 9; m++) {
                BigInt biPower10K = 10;
                BigInt biM = m;
                for (long k = 2; k <= 100; k++) {
                    for (long b = 1; b <= 9; b++) {
                        BigInt biB = b;
                        BigInt biRemainder;
                        BigInt biA; // = A
                        BigInt.DivAndMod((biB * (biPower10K - biM)), (10 * biM - 1), out biRemainder, out biA);
                        if (0 == biRemainder) {
                            BigInt biN = biA * 10 + biB;
                            if (biN > biPower10K) {
                                //Console.WriteLine(m + "-->" + k + "  " + biN.NumDigits + "  " + biQuotient.ToString() + " " + b);
                                sum = (sum + biN) % 100000;
                            }
                        }
                    }
                    biPower10K *= 10;
                }
            }
            return Convert.ToUInt64(sum.ToString());
        }
        #endregion
        #region Problem 169
        private void _169_Sub(BigInt n, out BigInt a, out BigInt b) {
            if (n == 0) {
                a = 1;
                b = 0;
            }
            else {
                BigInt a_, b_;
                _169_Sub(n / 2, out a_, out b_);
                if (0 == (n % 2)) {
                    a = a_ + b_;
                    b = b_;
                }
                else {
                    a = a_;
                    b = a_ + b_;
                }
            }
        }
        public string Problem169() {
            BigInt n = BigInt.Power(10,25);
            BigInt a, b;
            _169_Sub( n, out a, out b );
            return a.ToString();
        }
        #endregion
        #region Problem 170
        //static List<string[]> _170_Permutations = null;
        //private void _170_PreparePermutations() {
        //    _170_Permutations = new List<string[]>();
        //    for (int n = 1; n < 10; n++) {
        //        string s = "";
        //        for (int i = 1; i < n; i++)
        //            s += i.ToString();
        //        _170_Permutations.Add( Permutations(s) );
        //    }
        //}
        //private ulong _170_BestConcat(List<ulong> set, ulong multiplier) {
        //    ulong bestConcat = 0;
        //    string[] permutations = _170_Permutations[set.Count - 1];
        //    foreach (string permutation in permutations) {
        //        string concat = "";
        //        foreach (char c in permutation) {
        //            int idx = ToInt32(c);
        //            ulong product = multiplier * set[idx];
        //            concat += product.ToString();
        //        }
        //        ulong value = Convert.ToUInt64(concat);
        //        if (value > bestConcat)
        //            bestConcat = value;
        //    }
        //    return bestConcat;
        //}
        //private void _170_Extract(string permutation, int totalLength, List<ulong> set, ref ulong largest, ref List<ulong> bestSet) {
        //    // Heuristics: multiplier < 100   other >= 100
        //    int min = 1;
        //    int max = permutation.Length;
        //    if (set.Count == 0) {
        //        max = 2;
        //        if (max > permutation.Length)
        //            max = permutation.Length;
        //    }
        //    else {
        //        min = 3;
        //        if (min > permutation.Length)
        //            min = permutation.Length;
        //    }
        //    for (int length = min; length <= max; length++) {
        //        ulong n = Convert.ToUInt64(permutation.Substring(0, length));
        //        if (set.Count == 0 && 0 != (n % 3)) continue; // multiplier must be a multiple of 3
        //        set.Add(n); // Push
        //        if (length == permutation.Length) {
        //            if (set.Count > 2) { // At least 2 numbers in product
        //                string concat = "";
        //                for (int i = 1; i < set.Count; i++) {
        //                    ulong product = set[0] * set[i];
        //                    concat += product.ToString();
        //                }
        //                // If pandigital
        //                if (concat.Length == totalLength && IsPandigitalAtoB(concat, '0', '9') ) {
        //                    ulong bestConcat = _170_BestConcat(set, set[0]);
        //                    if (bestConcat > largest) {
        //                        largest = bestConcat;
        //                        bestSet.Clear();
        //                        foreach (ulong item in set)
        //                            bestSet.Add(item);
        //                    }
        //                }
        //            }
        //        }
        //        else {
        //            if (set.Count < 3) { // Heuristics: exactly 3 items in the set
        //                // Recursive call with the remaining string
        //                string remaining = permutation.Substring(length);
        //                if (remaining[0] != '0') // No leading 0
        //                    _170_Extract(remaining, totalLength, set, ref largest, ref bestSet);
        //            }
        //        }
        //        set.RemoveAt(set.Count - 1); // Pop
        //    }
        //}
        public ulong Problem170() {
            // Split each permutation of 012345789 in 3 or more parts (n, a, b, ... )
            // n*a concat n*b concat n*c ... is pandigital
            // n concat a concat b concat c ... is pandigital

            //// Brute-force
            //_170_PreparePermutations();
            //ulong largest = 0;
            //string[] permutations = Permutations("0123456789");
            //int n = 0;
            //List<ulong> bestSet = new List<ulong>();
            //foreach (string permutation in permutations) {
            //    n++;
            //    if (permutation[0] == '0') continue; // No leading 0
            //    List<ulong> set = new List<ulong>();
            //    _170_Extract(permutation, permutation.Length, set, ref largest, ref bestSet);
            //}
            //return largest;

            // For each pandigital starting with 98
            //      split in 2 parts
            //      a > 99
            //      b the rest
            //          for each multiple of 3 < min( a, b )/2
            //              check if a/i [+] b/i [+] i is pandigital   [+] means concatenation
            bool fFound = false;
            ulong largest = 0;
            string[] permutations = Permutations("76543210");
            int index = 0;
            while (!fFound) {
                string s = "98" + permutations[index];
                ulong n = Convert.ToUInt64(s);
                ulong pow10 = 1000;
                for (int p = 3; p < 10 && !fFound; p++) { // a must be > 99
                    ulong a = n % pow10;
                    ulong b = n / pow10;
                    for (ulong i = 3; i < Math.Min(a, b) / 2 && !fFound; i += 3) {
                        if (0 == (a % i) && 0 == (b % i)) {
                            string concat = (a / i).ToString() + (b / i).ToString() + i.ToString();
                            if (concat.Length == 10 && IsPandigitalCharRange(concat, '0', '9')) {
                                largest = n;
                                fFound = true;
                                break;
                            }
                        }
                    }
                    pow10 *= 10;
                }
                index++;
            }
            return largest;
        }
        #endregion
        #region Problem 171 UNDER CONSTRUCTION
        private ulong _171_SumSquareDigits(ulong number) {
            ulong sum = 0;
            while (number >= 1) {
                ulong digit = number % 10;
                sum += digit * digit;
                number /= 10;
            }
            return sum;
        }
        private ulong Problem171() {
            // min f(n) = 1 if n = 10^k
            // max f(n) = k*9^2 if n = 10^k - 1
            // limit is 10^20-1  (> 64 bits)
            // so we have to build an isSquare array with the 20*9^2 first integers

            // if f(n) is a perfect square, f(n)*10^k is also a perfect square
            // if f(n) is a perfect square, every permutation of its digits is also a perfect square and any number of 0 may be added


            // 1->9 count=9
            // 10->99 count=13
            // 100->999 count=53
            // 1000->9999 count=332
            // 10000->99999 count=3118
            // 100000->999999 count=31653
            // 1000000->9999999 count=333638
            // 10000000->99999999 count=3273646
            // count(10^k->10^(k+1)-1) = 10^k / 3   raw approximation
            // 9 + 13 + 53 + 332 + 3 118 + 31 653 + 333 638 + 3 273 646 = 3 642 462


            const ulong limit = 10000;
            bool[] isPerfectSquare = new bool[20 * 81 + 1];
            for (int i = 0; i < isPerfectSquare.Length; i++)
                isPerfectSquare[i] = IsPerfectSquare((ulong)i);

            ulong count = 0;
            for (ulong n = 1; n <= limit; n++) {
                ulong sumSquareDigits = _171_SumSquareDigits(n);
                if (isPerfectSquare[sumSquareDigits]) {
                    Console.WriteLine(n + "->" + sumSquareDigits);
                    count++;
                }
            }
            return 0;
        }
        #endregion
        #region Problem 172
        private ulong _172_Cnk(ulong n, ulong k) {
            // n!/(k!(n-k)!)
            ulong result = 1;
            for (ulong i = k + 1; i <= n; i++)
                result *= i;
            for (ulong i = 1; i <= (n - k); i++)
                result /= i;
            return result;
        }
        private ulong _172_Sub(ulong d, ulong p) {
            if (0 == d)
                return 0;
            if (p < 4)
                return Pow(d, p);
            else
                return _172_Sub(d - 1, p) + p * _172_Sub(d - 1, p - 1) + _172_Cnk(p, 2) * _172_Sub(d - 1, p - 2) + _172_Cnk(p, 3) * _172_Sub(d - 1, p - 3);
        }
        public ulong Problem172() {
            return (_172_Sub(10, 18) * 9) / 10; // *9/10 to remove leading zeroes
        }
        #endregion
        #region Problem 173
        public ulong Problem173() {
            // Number of tiles needed for a square of side S -> 4(C-1)
            // Start with a square and add englobing square until limit is reached
            const ulong limit = 1000000;
            const ulong biggestSquare = (limit / 4) + 1;
            ulong count = 0;
            for (ulong i = 3; i <= biggestSquare; i++) {
                ulong tiles = 0;
                for (ulong j = i; j <= biggestSquare; j += 2) { // englobing square side is square side+2
                    tiles += 4 * (j - 1);
                    if (tiles <= limit)
                        count++;
                    else
                        break; // No need to continue with biggest square
                }
            }
            return count;
        }
        #endregion
        #region Problem 179
        public ulong Problem179() {
            const ulong limit = 10000000;
            ulong sqrtLimit = (ulong)(Math.Sqrt(limit) + 0.5);
            // Count divisors using sieve
            int[] sieve = new int[limit + 1];
            for (int i = 0; i < sieve.Length; i++)
                sieve[i] = 2;
            for (ulong i = 2; i <= sqrtLimit; i++) {
                ulong j = i * i;
                sieve[j]--;
                while (j <= limit) {
                    sieve[j] += 2;
                    j += i;
                }
            }
            //
            ulong count = 0;
            for (ulong i = 2; i < limit; i++)
                if (sieve[i] == sieve[i + 1])
                    count++;
            return count;
        }
        #endregion
        #region Problem 180 DOESNT WORK
        class _180_CFraction {
            public ulong numerator, denominator;
            public _180_CFraction(ulong numerator, ulong denominator) {
                this.numerator = numerator;
                this.denominator = denominator;
            }
            public void Simplify() {
                ulong a = numerator;
                ulong b = denominator;
                ulong r;
                while (0 != (r = a % b)) {
                    a = b;
                    b = r;
                }
                // b contains PGCD
                numerator /= b;
                denominator /= b;
            }
            public static _180_CFraction Add(_180_CFraction f1, _180_CFraction f2) {
                return new _180_CFraction(f1.numerator * f2.denominator + f2.numerator * f1.denominator, f1.denominator * f2.denominator);
            }
            public static void Simplify(ref ulong numerator, ref ulong denominator) {
                ulong a = numerator;
                ulong b = denominator;
                ulong r;
                while (0 != (r = a % b)) {
                    a = b;
                    b = r;
                }
                // b contains PGCD
                numerator /= b;
                denominator /= b;
            }
            public override string ToString() {
                return numerator.ToString() + "/" + denominator.ToString();
            }
        }
        class _180_CFraction_EqualityComparer : IEqualityComparer<_180_CFraction> {
            #region IEqualityComparer<_180_CFraction> Members
            bool IEqualityComparer<_180_CFraction>.Equals(_180_CFraction x, _180_CFraction y) {
                return x.numerator == y.numerator && x.denominator == y.denominator;
            }

            int IEqualityComparer<_180_CFraction>.GetHashCode(_180_CFraction obj) {
                return obj.numerator.GetHashCode() ^ obj.denominator.GetHashCode();
            }
            #endregion
        }
        private ulong Problem180() {
            // f1n(x,y,z) = x^(n+1) + y^(n+1) - z^(n+1)
            // f2n(x,y,z) = (xy+yz+zx) * (x^(n-1) + y^(n-1) - z^(n-1))
            // f3n(x,y,z) = xyz * (x^(n-2) + y^(n-2) - z^(n-2))
            // fn(x,y,z) = f1n(x,y,z) + f2n(x,y,z) - f3n(x,y,z)
            // fn(x,y,z) = x^(n+1) + y^(n+1) - z^(n+1) + (xy+yz+zx) * (x^(n-1) + y^(n-1) - z^(n-1)) - xyz * (x^(n-2) + y^(n-2) - z^(n-2))
            // fn(x,y,z) = x^(n+1) + y^(n+1) - z^(n+1) + y*x^n + x*y^n - x*y*z^(n-1) + y*z*x^(n-1) + z*y^n - y*z^n + z*x^n + x*z*y^(n-1) - x*z^n - y*z*x^(n-1) - x*z*y^(n-1) - x*y*z^(n-1)
            // fn(x,y,z) = (x+y+z) * (x^n + y^n - z^n)
            // 
            // fn(x,y,z) = 0
            // if x+y+z = 0, impossible because x, y, z > 0
            // or (x^n + y^n - z^n) = 0
            // impossible for |n| > 2 (fermat theorem)
            // n = 2:  z = sqrt(x^2+y^2)
            // n = 1:  z = x+y
            // n = -1: z = xy / (x+y)
            // n = -2: z = xy / sqrt(x^2+y^2)

            // order=10 -> solution=12519  with 76 fractions in sums

            const ulong order = 35;
            // Create fractions
            Dictionary<_180_CFraction, bool> fractions = new Dictionary<_180_CFraction, bool>(new _180_CFraction_EqualityComparer());
            for (ulong denominator = 1; denominator <= order; denominator++)
                for (ulong numerator = 1; numerator <= denominator - 1; numerator++) {
                    _180_CFraction fraction = new _180_CFraction(numerator, denominator);
                    fraction.Simplify();
                    if (!fractions.ContainsKey(fraction))
                        fractions.Add(fraction, true);
                }
            // Compute z for each pair of fraction x, y
            // If z is in fractions, store x+y+z if not already stored
            Dictionary<_180_CFraction, int> sums = new Dictionary<_180_CFraction, int>(new _180_CFraction_EqualityComparer());
            foreach (KeyValuePair<_180_CFraction, bool> kvx in fractions)
                foreach (KeyValuePair<_180_CFraction, bool> kvy in fractions) {
                    _180_CFraction x = kvx.Key;
                    _180_CFraction y = kvy.Key;
                    // Sum
                    // Compute sqrt( x^2 + y^2 )
                    ulong numeratorSqrt = x.numerator * x.numerator * y.denominator * y.denominator + y.numerator * y.numerator * x.denominator * x.denominator;
                    ulong denominatorSqrt = x.denominator * x.denominator * y.denominator * y.denominator;
                    _180_CFraction.Simplify(ref numeratorSqrt, ref denominatorSqrt);
                    // Test n=2 and n=-2 only if sqrt(x^2 + y^2) is a perfect square
                    if (IsPerfectSquare(numeratorSqrt) && IsPerfectSquare(denominatorSqrt)) {
                        numeratorSqrt = (ulong)Math.Sqrt(numeratorSqrt);
                        denominatorSqrt = (ulong)Math.Sqrt(denominatorSqrt);
                        _180_CFraction.Simplify(ref numeratorSqrt, ref denominatorSqrt);
                        // n = 2
                        _180_CFraction zn2 = new _180_CFraction(numeratorSqrt, denominatorSqrt);
                        zn2.Simplify();
                        if (fractions.ContainsKey(zn2)) {
                            _180_CFraction sum = _180_CFraction.Add(x, y);
                            sum = _180_CFraction.Add(sum, zn2);
                            sum.Simplify();
                            if (sums.ContainsKey(sum))
                                sums[sum]++;
                            else
                                sums.Add(sum, 1);
                            //Console.WriteLine("x=" + x.ToString() + "   y=" + y.ToString() + "  zn2=" + zn2.ToString());
                        }
                        // n = -2  -> x*y / n2
                        _180_CFraction zn_2 = new _180_CFraction(x.numerator * y.numerator * zn2.denominator, x.denominator * y.denominator * zn2.numerator);
                        zn_2.Simplify();
                        if (fractions.ContainsKey(zn_2)) {
                            _180_CFraction sum = _180_CFraction.Add(x, y);
                            sum = _180_CFraction.Add(sum, zn_2);
                            sum.Simplify();
                            if (sums.ContainsKey(sum))
                                sums[sum]++;
                            else
                                sums.Add(sum, 1);
                            //Console.WriteLine("x=" + x.ToString() + "   y=" + y.ToString() + "  zn_2=" + zn_2.ToString());
                        }
                    }
                    // n = 1
                    _180_CFraction zn1 = _180_CFraction.Add(x, y);
                    zn1.Simplify();
                    if (fractions.ContainsKey(zn1)) {
                        _180_CFraction sum = _180_CFraction.Add(x, y);
                        sum = _180_CFraction.Add(sum, zn1);
                        sum.Simplify();
                        if (sums.ContainsKey(sum))
                            sums[sum]++;
                        else
                            sums.Add(sum, 1);
                        //Console.WriteLine("x=" + x.ToString() + "   y=" + y.ToString() + "  zn1=" + zn1.ToString());
                    }
                    // n = -1  -> x*y / n1
                    _180_CFraction zn_1 = new _180_CFraction(x.numerator * y.numerator * zn1.denominator, x.denominator * y.denominator * zn1.numerator);
                    zn_1.Simplify();
                    if (fractions.ContainsKey(zn_1)) {
                        _180_CFraction sum = _180_CFraction.Add(x, y);
                        sum = _180_CFraction.Add(sum, zn_1);
                        sum.Simplify();
                        if (sums.ContainsKey(sum))
                            sums[sum]++;
                        else
                            sums.Add(sum, 1);
                        //Console.WriteLine("x=" + x.ToString() + "   y=" + y.ToString() + "  zn_1=" + zn_1.ToString());
                    }
                }
            _180_CFraction total = new _180_CFraction(0, 1);
            foreach (KeyValuePair<_180_CFraction, int> kv in sums) {
                total = _180_CFraction.Add(total, kv.Key);
                total.Simplify();
            }
            return total.numerator + total.denominator;
        }
        #endregion
        #region Problem 183
        public ulong Problem183() {
            // f(k) = (N/k)^k
            // f'(k) = ((N/k)^k)(ln(N/k)-1)
            // max when f'(k) = 0, so when ln(N/k)-1 = 0 => ln(N/k) = 1 => N/k = e => k = N/e
            const ulong limit = 10000;
            long sum = 0;
            for (ulong i = 5; i <= limit; i++) {
                // Compute kMax
                ulong kMax = (ulong)(0.5 + (double)i / Math.E);
                // Check if terminating decimal or not
                // simplify denominator of fraction i/k
                // if the simplified denominator is divisible only by 2s or 5s the number is a terminating decimal
                ulong pgcd = PGCD(i, kMax);
                kMax /= pgcd; // simplify denominator
                while (0 == (kMax & 1)) // divides by 2 as much as possible
                    kMax /= 2;
                while (0 == (kMax % 5)) // divides by 5 as much as possible
                    kMax /= 5;
                if (1 == kMax) // terminating
                    sum -= (long)i;
                else
                    sum += (long)i;
            }
            return (ulong)sum;
        }
        #endregion
        #region Problem 187
        public ulong Problem187() {
            // Brute-force
            // TODO:
            // using prime array
            // foreach prime p1
            //   binary search in prime array to find the biggest p2 such as p1*p2 < limit
            //   count += index p2 - index p1 + 1
            const ulong limit = 100000000;
            ulong sqrtLimit = (ulong)(Math.Sqrt(limit) + 0.5);
            ulong sieveLimit = limit / 2;
            bool[] sieve = BuildSieve(1 + sieveLimit);
            ulong count = 0;
            for (ulong i = 2; i <= sqrtLimit; i++) {
                if (sieve[i]) continue;
                for (ulong j = i; j <= sieveLimit; j++) {
                    if (sieve[j]) continue;
                    ulong product = i * j;
                    if (product >= limit)
                        break; // once the limit is reached, next product will also exceed limit
                    count++;
                }
            }
            return count;
        }
        #endregion
        #region Problem 188
        public ulong Problem188() {
            // (a*a*a)%n = ((a%n)*(a%n)*(a%n)) %n
            const ulong last8digits = 100000000;

            ulong previousNumber = 0;
            ulong number = 1;
            ulong exponent = 1855;
            while (exponent > 0) {
                number = FastPowModulo_BeCareful(1777, number, last8digits);
                exponent--;
                if (number == previousNumber)
                    break;
                previousNumber = number;
            }
            return number;
        }
        #endregion
        #region Problem 197
        public string Problem197() {
            // No need to compute until n = 10^12 because Un 9 first decimals doesn't change after a few iterations
            // So, we loop until we have enough precision
            double Un_2 = 0;
            double Un_1 = 0;
            double Un = -1; // U0
            ulong n = 1;
            while (Math.Abs(Un - Un_2) > 0.00000000001) { // 11 decimals to be sure
                Un_2 = Un_1;
                Un_1 = Un;
                Un = Math.Floor(Math.Pow(2, 30.403243784 - Un_1 * Un_1)) * 0.000000001;
                //Console.WriteLine(n + "->" + Un + "  " + (Un + Un_1));
                n++;
            }
            return Math.Round(Un + Un_1, 9).ToString().Replace(',', '.');
        }
        #endregion
        #region Problem 203
        public ulong Problem203() {
            // Triangle[i,j] = Triangle[i-1,j-1] + Triangle[i,j-1]
            // Check for each distinct coefficient if it's divisible by any square of prime between 2^2 and 7^2 (highest square below 51)
            const int limit = 51;
            ulong[] primes = { 2, 3, 5, 7 };
            ulong[] line = { 1, 2, 1 }; // 3rd line of pascal triangle
            Dictionary<ulong, ulong> dict = new Dictionary<ulong, ulong>();
            while (line.Length <= limit) {
                // Get distinct coefficient
                for (int i = 0; i < line.Length; i++)
                    if (!dict.ContainsKey(line[i]))
                        dict.Add(line[i], line[i]);
                // Compute next triangle line
                ulong[] newLine = new ulong[line.Length + 1];
                newLine[0] = 1;
                newLine[newLine.Length - 1] = 1;
                for (int i = 1; i < line.Length; i++)
                    newLine[i] = line[i - 1] + line[i];
                line = newLine;
            }
            // Sum square-free distinct coefficient
            ulong sum = 0;
            foreach (KeyValuePair<ulong, ulong> kv in dict) {
                bool fOk = true;
                foreach (ulong prime in primes) {
                    ulong squaredPrime = prime * prime;
                    if (squaredPrime <= kv.Key && 0 == (kv.Key % squaredPrime)) {
                        fOk = false;
                        break;
                    }
                }
                if (fOk)
                    sum += kv.Key;
            }
            return sum;
        }
        #endregion
        #region Problem 204
        public ulong Problem204() {
            // Out of memory :p
            //const ulong hamming = 100;
            //const ulong limit = 1000000000+1;
            //ulong[] sieve = new ulong[limit];
            //for (ulong i = 0; i < limit; i++) sieve[i] = i;
            //for (ulong i = 2; i <= hamming; i++)
            //    for (ulong j = i; j < limit; j += i)
            //        if (j > hamming) {
            //            ulong n = sieve[j];
            //            while (0 == (n % i))
            //                n /= i;
            //            sieve[j] = n;
            //        }
            //ulong count = 0;
            //for (ulong i = 0; i < limit; i++)
            //    if (sieve[i] == 1)
            //        count++;
            //return count;

            // Too slow
            //const ulong limit = 1000000000;
            //ulong[] primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97 }; // primes < 100
            //ulong count = 0;
            //for (ulong i = 1; i <= limit; i++) {
            //    ulong n = i;
            //    foreach (ulong prime in primes) {
            //        while (0 == (n % prime))
            //            n /= prime;
            //        if (n == 1) {
            //            count++;
            //            break;
            //        }
            //    }
            //}
            //return count;

            const ulong limit = 1000000000;
            ulong[] primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97 }; // primes < 100
            SortedDictionary<ulong, ulong> multiples = new SortedDictionary<ulong, ulong>();

            multiples.Add(1, 1);
            foreach (ulong prime in primes) {
                ulong multiple = 1;
                List<ulong> toAdd = new List<ulong>();
                while (true) {
                    multiple *= prime;
                    if (multiple > limit)
                        break;
                    foreach (KeyValuePair<ulong, ulong> kv in multiples) {
                        ulong tmp = multiple * kv.Key;
                        if (tmp > limit)
                            break;
                        toAdd.Add(tmp);
                    }
                }
                foreach (ulong m in toAdd)
                    if (!multiples.ContainsKey(m))
                        multiples.Add(m, m);
            }
            return (ulong)multiples.Count;
        }
        #endregion
        #region Problem 205
        public string Problem205() {
            // Spent many hours to figure out why my answer was not correct
            // Answer must include 0.   so it's the probability rounded at 7 decimals
            ulong ppCount = 0;
            ulong[] pp = new ulong[36];
            for (int i = 0; i < pp.Length; i++) pp[i] = 0;
            for (ulong i = 1; i <= 4; i++)
                for (ulong j = 1; j <= 4; j++)
                    for (ulong k = 1; k <= 4; k++)
                        for (ulong l = 1; l <= 4; l++)
                            for (ulong m = 1; m <= 4; m++)
                                for (ulong n = 1; n <= 4; n++)
                                    for (ulong o = 1; o <= 4; o++)
                                        for (ulong p = 1; p <= 4; p++)
                                            for (ulong q = 1; q <= 4; q++) {
                                                ppCount++;
                                                ulong sum = i + j + k + l + m + n + o + p + q;
                                                pp[sum - 1]++;
                                            }
            ulong ccCount = 0;
            ulong[] cc = new ulong[36];
            for (int i = 0; i < cc.Length; i++) cc[i] = 0;
            for (ulong i = 1; i <= 6; i++)
                for (ulong j = 1; j <= 6; j++)
                    for (ulong k = 1; k <= 6; k++)
                        for (ulong l = 1; l <= 6; l++)
                            for (ulong m = 1; m <= 6; m++)
                                for (ulong n = 1; n <= 6; n++) {
                                    ccCount++;
                                    ulong sum = i + j + k + l + m + n;
                                    cc[sum - 1]++;
                                }
            double prob = 0;
            for (ulong i = 0; i < 36; i++)
                for (ulong j = 0; j < i; j++)
                    prob += ((double)pp[i] * (double)cc[j]);// / (double)(ppCount * ccCount);
            prob = prob / ((double)ppCount * (double)ccCount);
            return Math.Round(prob, 7).ToString().Replace(',', '.');
        }
        #endregion
        #region Problem 206
        public ulong Problem206() {
            // 1_2_3_4_5_6_7_8_9_0
            // must end with 00
            // use 1_2_3_4_5_6_7_8_9 and multiply result by 10
            // must end with an odd number
            string pattern = "1_2_3_4_5_6_7_8_9";
            BigInt n = 138902663; // sqrt(19293949596979899) which is the highest number possible
            while (true) {
                BigInt square = n * n;
                string s = square.ToString();
                if (s.Length < pattern.Length)
                    break; // no answer
                char[] arr = s.ToCharArray();
                bool fOk = true;
                for (int i = 0; i < arr.Length; i++)
                    if ((i & 1) == 0 && arr[i] != pattern[i]) {
                        fOk = false;
                        break;
                    }
                if (fOk)
                    break; // found
                n -= 2; // odd number
            }
            n *= 10;
            return Convert.ToUInt64(n.ToString());
        }
        #endregion
        #region Problem 214
        public ulong Problem214() {
            // Brute-force
            //const ulong limit = 40000000;
            //const ulong chainLength = 25;
            //bool[] sieve = BuildSieve(limit);
            //ulong[] totients = new ulong[limit+1];
            //totients[1] = 1;
            //totients[2] = 1;
            //totients[3] = 2;
            //totients[4] = 2;
            //totients[5] = 4;
            //totients[6] = 2;
            //ulong filled = 7;
            //ulong n = 7;
            //ulong sum = 0;
            //while (n <= limit) {
            //    if (0 == totients[n]) {
            //        ulong totient = Phi(sieve, n);
            //        totients[n] = totient;
            //        filled++;
            //        // phi(n*m) = phi(n)*phi(m) * d / phi(d)  with d = PGCD(m,n)
            //        // Calculate phi of multiple of multiple < n
            //        for (ulong multiple = 2; multiple < n; multiple++) {
            //            ulong product = multiple * n;
            //            if (product >= limit)
            //                break;
            //            ulong totientMultiple = totients[multiple];
            //            if (0 == totientMultiple) throw new Exception("!!!");
            //            ulong pgcd = PGCD(n, multiple);
            //            ulong totientPGCD = totients[pgcd];
            //            if (0 == totientPGCD) throw new Exception("!!!");
            //            totients[product] = (totient * totientMultiple * pgcd) / totientPGCD;
            //            filled++;
            //        }
            //    }
            //    if (!sieve[n]) {
            //        ulong count = 2;
            //        ulong step = totients[n];
            //        while (1 != step) {
            //            step = totients[step];
            //            count++;
            //            if (count > chainLength)
            //                break;
            //        }
            //        if (chainLength == count)
            //            sum += n;
            //    }
            //    n++;
            //}
            //return sum;

            // phi(n*m) = phi(n)*phi(m) * d / phi(d)  with d = PGCD(m,n)
            // if m is prime, phi(n*m) = phi(n)*phi(m)
            const ulong limit = 40000000;
            const ulong chainLength = 25;
            bool[] primes = new bool[limit];
            ulong[] totients = new ulong[limit];
            // Init
            for (ulong i = 0; i < limit; i++) {
                primes[i] = true; // in the beginning was the prime
                totients[i] = i;
            }
            // Compute totient
            for (ulong i = 2; i < limit; i++)
                if (primes[i]) {
                    ulong j = i * 2;
                    // Totient of prime is prime-1
                    totients[i] = i - 1;
                    // Compute totient of multiple
                    while (j < limit) {
                        primes[j] = false; // composite
                        totients[j] = totients[j] * (i - 1) / i; // See definition of totient
                        j += i;
                    }
                }
            // Count and sum, totient function is stricly increasing
            ulong sum = 0;
            ulong[] count = new ulong[limit];
            count[1] = 1;
            for (ulong i = 2; i < limit; i++) {
                count[i] = count[totients[i]] + 1;
                if (count[i] == chainLength && primes[i])
                    sum += i;
            }
            return sum;
        }
        #endregion
        #region Problem 225
        public ulong Problem225() {
            // let i the number to test
            // compute Tn-2, Tn-1, Tn modulo i
            // stop computing when Tn-2 == Tn-1 == Tn == 1 or Tn = 0 (restart the sequence or Tn is divisible by i)
            ulong c = 0;
            ulong i = 27;
            while (true) {
                ulong tn_2 = 1;
                ulong tn_1 = 1;
                ulong tn = 3;
                while (tn > 0 && tn * tn_1 * tn_2 != 1) {
                    ulong old_tn_2 = tn_2;
                    ulong old_tn_1 = tn_1;
                    ulong old_tn = tn;
                    tn_2 = old_tn_1;
                    tn_1 = old_tn;
                    tn = (old_tn + old_tn_1 + old_tn_2) % i;
                }
                if (tn > 0) {
                    // not divisible
                    c++;
                    if (c == 124)
                        break;
                }
                i += 2; // odd
            }
            return i;
        }
        #endregion
        #region Problem 230
        public ulong Problem230() {
            const string A = "1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679";
            const string B = "8214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196";
            ulong length = (ulong)A.Length; // A and B has the same length
            double phi = (1.0 + Math.Sqrt(5)) / 2.0;
            ulong pow10 = 1;
            ulong pow7 = 1;
            ulong sum = 0;
            for (ulong n = 0; n <= 17; n++) {
                ulong digitIndex = (127 + 19 * n) * pow7;
                int stringIndex = (int)((digitIndex - 1) % length);
                ulong whichString = (digitIndex - 1) / length;
                double d = phi * (double)(((ulong)((double)whichString / phi)));
                ulong digit = 0;
                int k = 0;
                if ((double)(whichString - 1) <= d && d < (double)whichString) {
                    digit = ToUInt64(B[stringIndex]);
                    k = 1;
                }
                else {
                    digit = ToUInt64(A[stringIndex]);
                    k = 0;
                }
                Console.WriteLine(digitIndex + "  " + d + "  " + stringIndex + "  " + k + "  " + digit);
                sum += digit * pow10;
                pow10 *= 10;
                pow7 *= 7;
            }
            return sum;
        }
        #endregion
        #region Problem 231
        private ulong _231_PrimeFactorExponentOfFactorial(ulong n, ulong p) {
            // http://homepage.smc.edu/kennedy_john/NFACT.PDF
            // page 8
            ulong sum = 0;
            while (n > 0) {
                n /= p;
                sum += n;
            }
            return sum;
        }
        public ulong Problem231() {
            // Cnk = n! / (k! * (n-k)! )
            // sum terms of prime factorisation (a*b) = sum terms of prime factorisation (a) + sum terms of prime factorisation (b)
            // stpf(12*18) = stpf(12) + stpf(18)
            // 12*18 = 2^2*3^1 * 2^1*3^2 = 2^(2+1)*3^(1+3)
            // stpf(12*18) = 2*3 + 3*3
            // stpf(12) = 2*2+3*1
            // stpf(18) = 2*1+3*2
            // same thing for division
            // prime factors of a factorial: http://answers.yahoo.com/question/index?qid=20091027134709AAVJlxi
            const ulong n = 20000000;
            const ulong k = 15000000;
            bool[] sieve = BuildSieve(n);
            ulong sum = 0;
            for (ulong p = 2; p < (ulong)sieve.Length; p++)
                if (!sieve[p]) {
                    ulong primeFactorExponentOfCnk = _231_PrimeFactorExponentOfFactorial(n, p) - (_231_PrimeFactorExponentOfFactorial(k, p) + _231_PrimeFactorExponentOfFactorial(n - k, p));
                    sum += p * primeFactorExponentOfCnk;
                }
            return sum;
        }
        #endregion
        #region Problem 234
        //private bool _234_IsPrime(bool[] sieve, ulong n) {
        //    if (n < (ulong)sieve.Length)
        //        return !sieve[n];
        //    if (n <= 1) return false; // 0, 1
        //    if (n < 4) return true; // 2, 3
        //    if (0 == (n & 1)) return false; // even
        //    if (n < 9) return true; // 0, 1, 4, 6, 8 already rejected
        //    if (0 == (n % 3)) return false; // multiple of 3
        //    ulong sqrtN = (ulong)Math.Sqrt(n);
        //    ulong divisor = 5;
        //    while (divisor <= sqrtN) {
        //        if (0 == (n % divisor)) return false;
        //        divisor += 2;
        //        while (sieve[divisor])
        //            divisor+=2;
        //    }
        //    return true;
        //}
        //private ulong _234_SumOfMultipleOfDBetweenAandB(ulong a, ulong b, ulong d) {
        //    a = (a - 1) / d + 1;
        //    b = b / d;
        //    return (((b - a + 1) * (b + a)) / 2) * d;
        //}
        public ulong Problem234() {
            // Brute-force
            //const ulong limit = 999966663333;
            //ulong sqrtLimit = 2 * (ulong)(Math.Sqrt(limit) + 0.5);
            //bool[] sieve = BuildSieve(sqrtLimit);
            //ulong sum = 0;
            //for (ulong i = 4; i <= limit; i++) {
            //    if (!_234_IsPrime(sieve, i)) {
            //        double sqrtI = Math.Sqrt(i);
            //        ulong lps = (ulong)Math.Floor(sqrtI);
            //        if (0 == (lps & 1) && 2 != lps ) // only odd number <> 2
            //            lps--;
            //        while (sieve[lps])
            //            lps-=2;
            //        ulong ups = (ulong)Math.Ceiling(sqrtI);
            //        if (0 == (ups & 1) && 2 != lps) // only odd number <> 2
            //            ups++;
            //        while (sieve[ups])
            //            ups+=2;
            //        long check = 0;
            //        check += ( 0 == ( i % lps ) ) ? 1 : 0;
            //        check += ( 0 == ( i % ups ) ) ? 1 : 0;
            //        if ( 1 == check )
            //            sum += i;
            //    }
            //}
            //return sum;

            const ulong min = 5; // 4 is not semi-divisible, avoid some additional tests
            const ulong max = 999966663333;
            ulong sqrtMax = 2 * (ulong)(Math.Sqrt(max) + 0.5);
            bool[] sieve = BuildSieve(sqrtMax);
            ulong lps = 2;
            ulong ups = 3;
            ulong sum = 0;
            while (true) {
                // Count numbers between lps^2 and ups^2 divisible by previous or next (but not both)
                //ulong from = lps * lps + 1;
                //ulong to = ups * ups - 1;
                //if (from >= max)
                //    break;
                //if (from < min) from = min;
                //if (to > max) to = max;
                //for (ulong i = from; i <= to; i++) {
                //    long check = 0;
                //    check += (0 == (i % lps)) ? 1 : 0;
                //    check += (0 == (i % ups)) ? 1 : 0;
                //    if (1 == check)
                //        sum += i;
                //}

                // No need to iterate every number between lps^2 and ups^2, consider multiples of lps and ups (not both)
                //// Count numbers between lps^2 and ups^2 divisible by previous or next (but not both)
                //// Get multiple of lps
                //ulong from = lps * lps;
                //ulong to = ups * ups;
                //if (from >= max)
                //    break;
                //// Get multiple of lps
                //Dictionary<ulong, ulong> multipleOfLps = new Dictionary<ulong, ulong>();
                //for (ulong i = from + lps; i <= to; i += lps)
                //    if (i >= min && i <= max)
                //        multipleOfLps.Add(i, i);
                //// Get multiple of ups
                //Dictionary<ulong, ulong> multipleOfUps = new Dictionary<ulong, ulong>();
                //for (ulong i = to - ups; i >= from; i -= ups)
                //    if (i >= min && i <= max)
                //        multipleOfUps.Add(i, i);
                //// Add elements found only in one of the 2 list
                //foreach (KeyValuePair<ulong, ulong> kv in multipleOfLps)
                //    if (!multipleOfUps.ContainsKey(kv.Key))
                //        sum += kv.Key;
                //foreach (KeyValuePair<ulong, ulong> kv in multipleOfUps)
                //    if (!multipleOfLps.ContainsKey(kv.Key))
                //        sum += kv.Key;

                // No need of a dictionary, consider the numbers divisible only by lps or ups (not both)
                ulong from = lps * lps;
                ulong to = ups * ups;
                if (from >= max)
                    break;
                // Get multiple of lps not multiple of ups
                for (ulong i = from + lps; i <= to; i += lps)
                    if (i >= min && i <= max && 0 != (i % ups))
                        sum += i;
                // Get multiple of ups not multiple of lps
                for (ulong i = to - ups; i >= from; i -= ups)
                    if (i >= min && i <= max && 0 != (i % lps))
                        sum += i;

                // Doesn't work
                //// Compute numbers between lps^2 and ups^2 divisible by previous or next (but not both)
                //ulong from = lps * lps + 1;
                //ulong to = ups * ups - 1;
                //if (from >= max)
                //    break;
                //if (from > max)
                //    from = max;
                //sum += (
                //    _234_SumOfMultipleOfDBetweenAandB(from, to, lps)
                //    + _234_SumOfMultipleOfDBetweenAandB(from, to, ups)
                //    - 2 * _234_SumOfMultipleOfDBetweenAandB(from, to, lps * ups));

                // Next prime pair
                lps = ups;
                ups += 2;
                while (sieve[ups]) // Get next prime
                    ups += 2;
            }
            return sum;
        }
        #endregion
        #region Problem 235
        public string Problem235() {
            // u(k) = (900-3k) * r^(k-1)
            // s(n) = sum(k=1->n,u(k))
            // find r for which s(5000) = -600000000000
            // s(n) is a monotonic decreasing function, so we can use a binary search to find r
            // may divide s(n) by 3
            // u(k) = (300-k) * r^(k-1)
            // s(n) = sum(k=1->n,u(k))
            // find r for which s(5000) = -200000000000
            const double target = -200000000000;
            const int count = 5000;
            double r = 1;
            double delta = 0.125;
            double sum = 0;
            while (Math.Abs(sum - target) > 1) {
                sum = 0;
                for (int i = 1; i <= count; i++)
                    sum += (300 - (double)i) * Math.Pow(r, i - 1);
                if (sum > target)
                    r = (r + delta);
                else
                    r = (r - delta);
                delta *= 0.5;
            }
            return Math.Round(r, 12).ToString().Replace(',', '.');
        }
        #endregion
        #region Problem 243
        public ulong Problem243() {
            // number of resilient fraction for n = phi(n)
            // R(n) = phi(n) / (n-1) =  1/(n-1) * n * (p1-1)/p1 * (p2-1)/p2 ...
            // primorials(n) = p0 * p1 * p2 .. * pn where pk is the k-th prime
            // totient(a*b) = totient(a)*totient(b)
            // totient(p) = p-1 if p is prime
            // stop when 15499/94744 > totient(primorial)/#proper_fraction(primorial) (=primorial-1)
            // when limit is reached, we have to use previous value to compute Resilience
            // we know Resilience must be a multiple of primorial, so we only have to compute this multiple
            // and return primorial * multiple
            const ulong targetNumerator = 15499;
            const ulong targetDenominator = 94744;
            ulong oldPrimorial = 1;
            ulong oldTotient = 1;
            foreach (ulong p in Primes10) {
                ulong newPrimorial = oldPrimorial * p; // compute primorials
                ulong newTotient = oldTotient * (p - 1); // compute totient function of primorials
                // targetNumerator/targetDenominator > totient / (primorial-1)
                if (targetNumerator * (newPrimorial - 1) > newTotient * targetDenominator) {
                    // limit reached, use old primorial and old totient to compute the multiplier
                    // compute difference between target and current value
                    ulong difference = targetNumerator * oldPrimorial - targetDenominator * oldTotient;
                    ulong multiple = (targetNumerator + difference - 1) / difference; // integral division to get the multiple
                    return multiple * oldPrimorial;
                }
                oldPrimorial = newPrimorial;
                oldTotient = newTotient;
            }
            return 0;
        }
        #endregion
        #region Problem 245 UNDER CONSTRUCTION
        private ulong Problem245() {
            //        n - phi(n)     n - phi(n)   1
            // C(n) = ----------  =  ---------- . -  with k a positive integer
            //          n - 1        n - phi(n)   k
            // ( n - phi(n) ) * k = n - 1
            // ( phi(n) - 1 ) / ( n - 1 ) = ( k - 1 ) / k
            // k * phi(n) = k (mod n-1)
            return 0;
        }
        #endregion
        #region Problem 251 TOO SLOW
        private ulong Problem251() {
            //http://www77.wolframalpha.com/input/?i=((a%2Bbsqrt(c))^(1/3))+%2B+((a-bsqrt(c))^(1/3))+%3D+1 
            //http://compsci.ca/v3/viewtopic.php?t=21209&postdays=0&postorder=asc&start=90
            //http://cyzhao.blogbus.com/logs/55014616.html
            // 8a^2+15a^2+6a-1 = 27cb^2
            // right part is divisible by 3 -> left part must be divisible by 3, then a = 2 (mod 3)

            const ulong limit = 110000000;
            ulong count = 0;
            for (ulong a = 2; a < limit; a += 3) {
                double K = limit - a;
                double t = 1.0 - 2.0 * a;
                double S = a * a - t * t * t / 27.0;
                double b_min = 4.0 * S / K / K - 1;
                double b_max = Math.Sqrt(S) + 1;
                if (b_min < 1) b_min = 1;
                if (b_max > K) b_max = K;
                for (ulong b = (ulong)b_min; b <= (ulong)b_max; b++) {
                    ulong c = (ulong)S / b / b;
                    if (c >= 1 && (b * b * c) == S && (b + c) <= K) {
                        //cout<<"("<<a<<","<<b<<","<<c<<")"<<endl;
                        count++;
                    }
                }
            }
            return count;
        }
        #endregion
        #region Problem 258 TOO SLOW
        private ulong Problem258() {
            // Gk = Fk-2000
            const ulong limit = 1000000000000000000;
            const ulong mod = 20092010;
            ulong fn = 1;
            ulong fn_1 = 1;
            for (ulong n = 2000; n <= limit; n++) {
                ulong fn_2 = (fn + fn_1) % mod;
                fn = fn_1;
                fn_1 = fn_2;
            }
            return fn_1;
        }
        #endregion
        #region Problem 277 UNDER CONSTRUCTION
        private ulong Problem277() {
            // Let An be ( n - a ) / b
            // Compte n, a, b of An+1
            // U: ( n - a ) / b -> ( 4n - (4a-2b) ) / 3b  ==> n = 4n, a = 4a-2b, b = 3b
            // D: ( n - a ) / b -> ( n - a ) / 3b  ==> n = n, a = a, b = 3b
            // d: ( n - a ) / b -> ( 2n - (2a+b) ) / 3b  ==> n = 2n, a=2a+b, b = 3b

            // Build recurrence to get next number
            //const ulong limit = 1000000000000000;
            //string sequence = "DdDddUUdDD";
            //string sequence = "DdDddUUdDDDdUDUUUdDdUUDDDUdDD";
            const string sequence = "UDDDUdddDDUDDddDdDddDDUDDdUUDd";
            long n = 1;
            long a = 0;
            long b = 1;
            for (int i = 0; i < sequence.Length; i++) {
                //char c = sequence[sequence.Length-i-1];
                char c = sequence[i];
                switch (c) {
                    case 'U':
                        n = 4 * n;
                        a = 4 * a - 2 * b;
                        b = 3 * b;
                        break;
                    case 'D':
                        b = 3 * b;
                        break;
                    case 'd':
                        n = 2 * n;
                        a = 2 * a + b;
                        b = 3 * b;
                        break;
                    default:
                        n = 0;
                        break;
                }
                Console.WriteLine(c + "-->" + n + "  " + a + "  " + b);
            }

            // the iteration must end with 1
            // ( n*x - a ) / b = 1
            // x = ( b + a ) / n
            long x = (b + a) / n; // give lowest possible number if remainder = 0
            long remainder = (b + a) % n;
            //// TODO: get next value until limit is reached

            // Check
            long an = x;
            Console.WriteLine(an);
            for (int i = 0; i < sequence.Length; i++) {
                char operation = sequence[i];
                bool fStop = false;
                long mod = an % 3;
                switch (operation) {
                    case 'D':
                        if (0 != mod)
                            fStop = true;
                        else
                            an = an / 3;
                        break;
                    case 'U':
                        if (1 != mod)
                            fStop = true;
                        else
                            an = (4 * an + 2) / 3;
                        break;

                    case 'd':
                        if (2 != mod)
                            fStop = true;
                        else
                            an = (2 * an - 1) / 3;
                        break;
                }
                if (fStop)
                    break;
                Console.WriteLine(an);
            }

            if (1 != an)
                Console.WriteLine("ERROR");

            return 0;

            ////string sequence = "DdDddUUdDDDdUDUUUdDdUUDDDUdDD";
            ////ulong n = 1000000;
            //string sequence = "UDDDUdddDDUDDddDdDddDDUDDdUUDd";
            //ulong n = 1000000000000001+2;
            //ulong startN = n;
            //int idx = 0;
            //while (true) {
            //    char operation = sequence[idx];
            //    ulong mod = n % 3;
            //    switch (operation) {
            //        case 'D':
            //            if (0 != mod) {
            //                idx = 0;
            //                n = startN + 1;
            //                startN = n;
            //            }
            //            else {
            //                idx++;
            //                n = n / 3;
            //            }
            //            break;
            //        case 'U':
            //            if (1 != mod) {
            //                idx = 0;
            //                n = startN + 1;
            //                startN = n;
            //            }
            //            else {
            //                idx++;
            //                n = (4 * n + 2) / 3;
            //            }
            //            break;

            //        case 'd':
            //            if (2 != mod) {
            //                idx = 0;
            //                n = startN + 1;
            //                startN = n;
            //            }
            //            else {
            //                idx++;
            //                n = (2 * n - 1) / 3;
            //            }
            //            break;
            //    }
            //    if (idx == sequence.Length) {
            //        if (1 == n)
            //            break;
            //        idx = 0;
            //        n = startN + 1;
            //        startN = n;
            //    }
            //}
            //return startN;
        }
        #endregion
        #region Problem 293
        public ulong Problem293() {
            const ulong limit = 1000000000;
            ulong[] primes = new ulong[150];
            List<ulong> numbers = new List<ulong>();
            List<ulong> previousMultiples = new List<ulong>();

            // Compute 150 first primes
            ulong count = 1;
            primes[0] = 2;
            ulong n = 3;
            while (true) {
                if (IsPrime(n)) {
                    primes[count++] = n;
                    if (count >= 150)
                        break;
                }
                n += 2;
            }

            // Get power of 2 and multiples of primes
            ulong multiple;
            // Get all power of 2
            multiple = 1;
            while (true) {
                multiple = multiple * primes[0];
                if (multiple >= limit)
                    break;
                previousMultiples.Add(multiple);
                numbers.Add(multiple);
            }
            // Get all multiples of a prime and the multiples of the previous prime
            foreach (ulong prime in primes) {
                multiple = 1;
                List<ulong> currentMultiples = new List<ulong>();
                while (true) {
                    multiple *= prime;
                    if (multiple >= limit)
                        break;
                    foreach (ulong number in previousMultiples) {
                        ulong tmp = multiple * number;
                        if (tmp >= limit)
                            break;
                        currentMultiples.Add(tmp);
                        numbers.Add(tmp);
                    }
                }
                currentMultiples.Sort();
                previousMultiples = currentMultiples;
            }

            // For each of these numbers, find the next prime and build a list of distinct pseudo-fortunate numbers
            Dictionary<ulong, ulong> pseudo = new Dictionary<ulong, ulong>();
            ulong sum = 0;
            foreach (ulong number in numbers) {
                ulong nextPrime = number + 2; // Difference must be > 1
                if (0 == (nextPrime & 1))
                    nextPrime++; // Starts with an odd number
                while (!IsPrime(nextPrime))
                    nextPrime += 2; // skip even number
                ulong diff = nextPrime - number;
                if (!pseudo.ContainsKey(diff)) {
                    pseudo.Add(diff, diff);
                    sum += diff;
                }
            }

            return sum;
        }
        #endregion
        #region Problem 297 TOO SLOW
        private ulong Problem297() {
            //A007895
            const ulong limit = 1000000; // 10^17
            ulong sum = 2; // 1+1
            List<ulong> fibonacci = new List<ulong>();
            fibonacci.Add(1);
            fibonacci.Add(2);
            for (ulong i = 3; i < limit; i++) {
                // Compute next fibonacci
                if (i > fibonacci[fibonacci.Count - 1])
                    fibonacci.Add(fibonacci[fibonacci.Count - 1] + fibonacci[fibonacci.Count - 2]);
                // Get Zeckendorf representation of i
                //Console.Write(i+":");
                ulong count = 0;
                ulong n = i;
                int idx = fibonacci.Count - 1;
                while (true)
                    if (fibonacci[idx] > n)
                        idx--;
                    else {
                        //if (count > 0)
                        //    Console.Write("+");
                        //Console.Write(fibonacci[idx]);
                        count++;
                        if (fibonacci[idx] == n)
                            break;
                        n -= fibonacci[idx];
                        idx -= 2;
                    }
                sum += count;
                //Console.WriteLine(" -> "+count);
            }
            return sum;
        }
        #endregion
        #region Problem 303
        private void _303_GenerateBase3Numbers(ulong length, ulong prefix, List<ulong> list) {
            if (length == 1)
                for (ulong i = 0; i <= 2; i++)
                    list.Add(prefix + i);
            else
                for (ulong i = 0; i <= 2; i++) {
                    ulong newPrefix = i * Pow(10, length - 1) + prefix;
                    _303_GenerateBase3Numbers(length - 1, newPrefix, list);
                }
        }
        public ulong Problem303() {
            // TODO:
            //ull solve(int x)
            //{
            //    static int found[10010];
            //    memset(found, 0, sizeof(found));
            //    if (x < 3) return 1;
            //    queue<pair<ull, int> > q;
            //    q.push(make_pair(ull(1), 1));
            //    q.push(make_pair(ull(2), 2));
            //    found[1] = found[2] = 1;
            //    while (1) {
            //        ull n = q.front().first;
            //        int m = q.front().second;
            //        q.pop();
            //        if (m == 0) return n/x;
            //        for (int i = 0; i <= 2; i++) {
            //            int nm = (m * 10 + i) % x;
            //            if (!found[nm]) {
            //                found[nm] = 1;
            //                q.push(make_pair(n * 10 + (ull) i, nm));
            //            }
            //        }
            //    }
            //}

            //int main(void)
            //{
            //    int bases[2] = { 100, 10000 };
            //    for (int ti = 0; ti < 2; ti++) {
            //        ull r = 0;
            //        for (int i = 1; i <= bases[ti]; i++) r += solve(i);
            //        cout << "Up to " << bases[ti] << ": " << r << endl;
            //    }
            //    return 0;
            //}


            //// Brute-force
            //ulong limit = 10000;
            //ulong sum = 0;
            //for (ulong n = 1; n <= limit; n++) {
            //    ulong multiplier = 0;
            //    switch (n) {
            //        case 9: multiplier = 1358; break; // fn = 12222
            //        case 99: multiplier = 11335578; break; // fn = 1122222222
            //        case 495: multiplier = 22671156; break; // fn = 11222222220
            //        case 990: multiplier = 11335578; break; // fn = 11222222220
            //        case 999: multiplier = 1113335555778; break; // fn = 1112222220222222
            //        case 4995: multiplier = 2226671111556; break; // fn = 11122222202222220
            //        case 9990: multiplier = 1113335555778; break; // fn = 11122222202222220
            //        case 9999: multiplier = 1111333355555557778; break; // fn = 11112222222200022222222
            //        default: multiplier = 0; break;
            //    }
            //    if ( 0 == multiplier ) {
            //        // Compute f(n)
            //        multiplier = 1;
            //        ulong fn = n * multiplier;
            //        while (true) {
            //            bool fOk = true;
            //            ulong test = fn;
            //            while (test > 0) {
            //                ulong digit = test % 10;
            //                if (digit > 2) {
            //                    fOk = false;
            //                    break;
            //                }
            //                test /= 10;
            //            }
            //            if (fOk)
            //                break;
            //            fn += n; // next multiplier
            //            multiplier++;
            //        }
            //    }
            //    sum += multiplier;
            //    list.Add(multiplier);
            //}

            // 2^64-1 -> 10^19
            // Optimisation 1
            //  n * multiplier = fn
            //  n * 10 * multiplier = fn * 10  (fn * 10 will be written with only of 0, 1, 2)
            //  result[n*10] = multiplier
            // Optimisation 2 only if 2*n < limit
            //  for each divisor d of multiplier
            //      n * d * multiplier / d = fn
            //      result[n*d] = multiplier/d

            const ulong limit = 10000;
            ulong[] multiplierList = new ulong[limit + 1];
            // Generate numbers in base-3 (sorted)
            ulong digitCount = 15;
            List<ulong> base3List = new List<ulong>();
            _303_GenerateBase3Numbers(digitCount, 0, base3List); // Arbitrary limit
            base3List.RemoveAt(0); // Remove 0
            bool[] sieve = BuildSieve(limit); // Arbitrary limit
            ulong count = 0;
            multiplierList[0] = 0;
            // Compute Fn
            for (ulong n = 1; n <= limit; n++) {
                if (0 != multiplierList[n])
                    continue;
                count++;
                ulong multiplier = 0;
                switch (n) {
                    case 9: multiplier = 1358; break; // fn = 12222
                    case 99: multiplier = 11335578; break; // fn = 1122222222
                    case 495: multiplier = 22671156; break; // fn = 11222222220
                    //case 990: multiplier = 11335578; break; // fn = 11222222220
                    case 999: multiplier = 111333555778; break; // fn = 111222222222222
                    case 4995: multiplier = 222667111556; break; // fn = 1112222222222220
                    //case 9990: multiplier = 111333555778; break; // fn = 1112222222222220
                    case 9999: multiplier = 1111333355557778; break; // fn = 11112222222222222222
                    default: multiplier = 0; break;
                }
                // Search if n is a divisor of an item in base-3 list
                foreach (ulong fn in base3List) {
                    if (fn >= n) {
                        ulong mod = fn % n;
                        if (0 == mod) {
                            multiplier = fn / n;
                            break;
                        }
                    }
                }

                if (0 == multiplier) {
                    //// Not found in list, find it manually
                    //// first multiplier to test must be 10^digitCount / n
                    //// because 10^digitCount is the next base-3
                    //multiplier = Pow(10, digitCount) / n;
                    //ulong fn = n * multiplier;
                    //while (true) {
                    //    bool fOk = true;
                    //    ulong test = fn;
                    //    while (test > 0) {
                    //        ulong digit = test % 10;
                    //        if (digit > 2) {
                    //            fOk = false;
                    //            break;
                    //        }
                    //        test /= 10;
                    //    }
                    //    if (fOk)
                    //        break;
                    //    fn += n; // next multiplier
                    //    multiplier++;
                    //}
                    List<ulong> queue = new List<ulong>();
                    queue.Add(1);
                    queue.Add(2);
                    while (true) {
                        ulong fn = queue[0]; queue.RemoveAt(0);
                        if (fn >= n && 0 == (fn % n)) {
                            multiplier = fn / n;
                            break;
                        }
                        for (ulong i = 0; i <= 2; i++)
                            queue.Add(10 * fn + i);
                    }
                }
                multiplierList[n] = multiplier;
                // Optimisation 1
                ulong mul10 = n;
                while (true) {
                    mul10 *= 10;
                    if (mul10 > limit)
                        break;
                    multiplierList[mul10] = multiplier;
                }
                // Optimisation 2
                if (multiplier > 3 && 2 * n < limit) {
                    ulong sqrtMultipler = (ulong)(Math.Sqrt(multiplier) + 0.5);
                    ulong p = 2;
                    while (true) {
                        ulong test = multiplier;
                        ulong newN = n;
                        if (newN * p > limit) // stops if limit is reached
                            break;
                        while (test != p && 0 == (test % p)) {
                            test /= p;
                            newN *= p;
                            if (newN > limit) // stops if limit is reached
                                break;
                            multiplierList[newN] = test;
                        }
                        if (2 == p)
                            p++;
                        else
                            p += 2;
                        while (p <= limit && sieve[p]) p += 2;
                        if (p > limit)
                            break;
                    }
                }
            }
            ulong sum = 0;
            foreach (ulong multiplier in multiplierList)
                sum += multiplier;

            //// DEBUG
            //using (System.IO.StreamWriter sw = new System.IO.StreamWriter(@"..\..\..\output.txt")) {
            //    for (ulong n = 1; n <= limit; n++) {
            //        ulong multiplier = multiplierList[n];
            //        if (multiplier == 0) {
            //            sw.WriteLine(n + "  !!!!!!!!!!!!!!!!NOT FOUND!!!!!!!!!!!!!");
            //        }
            //        else {
            //            ulong fn = n * multiplier;
            //            sw.WriteLine(n + " * " + multiplier + " = " + fn);
            //        }
            //    }
            //    sw.WriteLine("Sum=" + sum);
            //}
            return sum;
        }
        #endregion
        #region Problem 306
        private ulong _306_Sub(ulong a, ulong b) {
            return ( a >= b ) ? (ulong)1 : (ulong)0;
        }
        public ulong Problem306() {
            //http://huangyun.wikispaces.com/Project+Euler+Solution+306
            //http://arxiv.org/pdf/quant-ph/0311018
            ulong n = 1000000;
            ulong q = n / 34;
            ulong r = n % 34;
            // winning positions - losing positions
            return n - (_306_Sub(n, 1) + _306_Sub(n, 15) + _306_Sub(n, 35) + 5 * q + _306_Sub(r, 5) + _306_Sub(r, 9) + _306_Sub(r, 21) + _306_Sub(r, 25) + _306_Sub(r, 29));
        }
        #endregion

        private void SolveAllProblems() {
            Type thisType = this.GetType();

            using (System.IO.StreamWriter sw = new System.IO.StreamWriter(@"..\..\..\solveallproblems.txt")) {
                const int ProblemFrom = 100;
                const int ProblemTo = 100;
                System.Diagnostics.Stopwatch watch = new System.Diagnostics.Stopwatch();
                for (int i = ProblemFrom; i <= ProblemTo; i++) {
                    string problemName = "Problem" + i.ToString();
                    System.Reflection.MethodInfo method = thisType.GetMethod(problemName);
                    if (null == method) {
                        Console.WriteLine(problemName + " not yet solved");
                        sw.WriteLine(problemName + " not yet solved");
                    }
                    else {
                        try {
                            watch.Start();
                            object result = method.Invoke(this, null);
                            Console.WriteLine(method.Name + ": " + result + "    Execution time: " + watch.ElapsedMilliseconds + "ms");
                            sw.WriteLine(method.Name + ": " + result + "    Execution time: " + watch.ElapsedMilliseconds + "ms");
                            watch.Reset();
                        }
                        catch (Exception ex) {
                            Console.WriteLine(method.Name + "-> exception :" + ex.ToString());
                            sw.WriteLine(method.Name + "-> exception :" + ex.ToString());
                        }
                    }
                    sw.Flush();
                }
            }
        }

        static void Main(string[] args) {
            Program p = new Program();
            //p.SolveAllProblems();

            System.Diagnostics.Stopwatch sw = new System.Diagnostics.Stopwatch();
            sw.Start();
            ulong result = p.Problem166();
            sw.Stop();
            Console.WriteLine("Result: " + result + "    Execution time: " + sw.ElapsedMilliseconds + "ms");
        }
    }
}
